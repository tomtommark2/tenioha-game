<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ëã±ÂçòË™ûÂ≠¶Áøí„ÇØ„É™„ÉÉ„Ç´„Éº</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700;900&family=Poppins:wght@400;600;700;800&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            /* Deep Space / Magic Purple */
            background: linear-gradient(135deg, #13547a 0%, #80d0c7 100%);
            /* Let's try a fresh "Mystic Teal" or keep purple? 
               User liked the purple but maybe "Magic" needs more depth. 
               Let's go nicely deep purple/blue: */
            background: linear-gradient(135deg, #6B73FF 0%, #000DFF 100%);
            /* Deep Blue */
            background: linear-gradient(135deg, #9796f0 0%, #fbc7d4 100%);
            /* Pastel? No. */
            background: linear-gradient(135deg, #3b41c5 0%, #a981bb 49%, #ffc8a9 100%);
            /* Sunset Magic - nice breadth */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.85);
            /* Semi-transparent */
            backdrop-filter: blur(12px);
            /* Frosted Glass */
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            /* Subtle edge */
            border-radius: 24px;
            /* More modern roundness */
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.25);
            /* Colored shadow for depth */
            max-width: 900px;
            width: 100%;
        }

        .level-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: flex-end;
        }

        .level-btn {
            background: white;
            color: #555;
            border: 1px solid rgba(0, 0, 0, 0.05);
            padding: 10px 24px;
            border-radius: 50px;
            /* Pill shape */
            cursor: pointer;
            font-size: 15px;
            font-weight: 700;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .level-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.2);
        }

        .level-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .file-upload-area {
            background: #f8f9fa;
            border: 2px dashed #667eea;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .file-upload-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .file-upload-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .file-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }

        /* Progress Bar & Title Styles */
        .progress-section {
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        .title-display {
            font-size: 16px;
            font-weight: bold;
            color: #555;
        }

        .title-value {
            color: #d32f2f;
            font-size: 18px;
            margin-left: 5px;
        }

        .progress-text {
            font-size: 14px;
            color: #777;
            font-weight: bold;
        }

        .progress-bar-bg {
            background: #e0e0e0;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            margin-top: 8px;
            position: relative;
        }

        .progress-bar-fill {
            background: linear-gradient(90deg, #4caf50, #81c784);
            height: 100%;
            width: 0%;
            transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            /* Bouncy fill */
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            /* Glowing Bar */
        }

        .header {
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .stats {
            flex: 1;
        }

        .points {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            white-space: nowrap;
            /* Force single line */
        }

        .vocab-level {
            font-size: 18px;
            color: #666;
            margin-top: 5px;
        }

        .vocab-level-display {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        .play-time {
            font-size: 14px;
            color: #999;
            margin-top: 3px;
        }

        .mode-buttons {
            display: flex;
            gap: 10px;
        }

        .mode-btn {
            background: #e0e0e0;
            color: #333;
            border: none;
            padding: 8px 15px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 90px;
        }

        .mode-count {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 2px;
            font-weight: normal;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
        }

        .mode-btn.unlearned {
            background: #90caf9;
        }

        .mode-btn.learned {
            background: #4caf50;
            color: white;
        }

        .mode-btn.perfect {
            background: #ffd700;
            color: #333;
        }

        .mode-btn.weak {
            background: #f44336;
            color: white;
        }

        .stat-item.perfect {
            background: #fff9c4;
        }

        .mode-btn.active {
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }

        .mode-btn:disabled,
        .mode-btn.disabled {
            opacity: 0.8;
            /* Less transparent */
            cursor: not-allowed;
            pointer-events: none;
            filter: grayscale(30%);
            /* Subtle grayscale */
        }

        .mode-btn span {
            white-space: nowrap;
            /* Prevent text wrapping */
        }

        .random-notice {
            font-size: 11px;
            color: #999;
            margin-right: 10px;
        }

        .add-words-btn {
            background: #4caf50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .add-words-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .auto-mode-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s;
        }

        .auto-mode-container:hover {
            background: #e9ecef;
        }

        .auto-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #9c27b0;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .auto-checkbox.checked {
            background: #9c27b0;
        }

        .auto-checkbox.checked::after {
            content: '‚úì';
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .auto-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            white-space: nowrap;
            /* Prevent text wrapping */
        }

        .pos-filter-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-right: 10px;
        }

        .pos-checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s;
        }

        .pos-checkbox-item:hover {
            background: #e9ecef;
        }

        .pos-checkbox-item input[type="checkbox"] {
            cursor: pointer;
        }



        .main-content {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
        }

        .cards-section {
            flex: 1;
        }

        .cards-area {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }

        .card {
            flex: 1;
            background: white;
            /* Gradient Border/Glow effect can be done with box-shadow */
            border: none;
            border-radius: 20px;
            padding: 40px 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 240px;
            position: relative;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05), inset 0 0 0 2px #f0f0f5;
            /* Subtle border inset */
        }

        .card:hover {
            transform: translateY(-6px) scale(1.02);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.25);
            /* Border highlight on hover */
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.25), inset 0 0 0 2px #667eea;
        }

        .card:active {
            transform: translateY(-2px);
        }

        .card-label {
            position: absolute;
            top: 15px;
            font-size: 14px;
            color: #667eea;
            font-weight: bold;
        }

        .card-content {
            font-size: 36px;
            font-weight: bold;
            color: #333;
            text-align: center;
        }

        .meaning-card .card-content {
            font-size: 20px;
            line-height: 1.4;
        }

        .card-back {
            display: none;
        }

        .card.flipped .card-front {
            display: none;
        }

        .card.flipped .card-back {
            display: block;
        }

        .example-area {
            background: #fff9e6;
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speaker-btn {
            background: #667eea;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .speaker-btn:hover {
            background: #5568d3;
            transform: scale(1.1);
        }

        .undo-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 4px 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            z-index: 10;
        }

        .undo-btn:hover {
            background: #e0e0e0;
            transform: scale(1.05);
        }

        .undo-btn:disabled {
            opacity: 0.5;
            cursor: default;
            transform: none;
        }

        .example-text {
            flex: 1;
        }

        .example-label {
            font-size: 11px;
            color: #996600;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .example-sentence {
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        .character-area {
            width: 200px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .character {
            font-size: 80px;
            margin: 20px 0;
        }

        .character-title {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .character-level {
            font-size: 14px;
            color: #666;
        }

        .no-words {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 18px;
        }

        .coin-popup {
            position: fixed;
            top: 30px;
            left: 200px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.6);
            z-index: 1000;
            animation: popupSlide 0.6s ease-out;
            pointer-events: none;
        }

        @keyframes popupSlide {
            0% {
                transform: translateX(-20px);
                opacity: 0;
            }

            50% {
                transform: translateX(10px);
                opacity: 1;
            }

            100% {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .review-badge {
            position: absolute;
            top: 50px;
            right: 15px;
            background: #4caf50;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        .character.working .card.working {
            animation: bounce 0.5s ease-in-out;
        }
    </style>
    <style>
        /* ... previous styles ... */
        .character-area,
        .vocab-level,
        .play-time {
            display: none !important;
        }

        /* New generic small button style */
        .icon-btn {
            background: #f0f0f0;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
            color: #666;
        }

        .icon-btn:hover {
            background: #e0e0e0;
            transform: scale(1.1);
        }

        .header-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 200;
        }

        .file-info-small {
            font-size: 12px;
            color: #888;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* RPG Styles */
        /* New Stats Position (Top Left) */
        .stats-absolute {
            position: absolute;
            top: 15px;
            left: 20px;
            z-index: 100;
            transform: scale(0.8);
            transform-origin: top left;
        }

        /* RPG Stage (Now Inline in Header) */
        .rpg-inline {
            position: relative;
            width: 140px;
            height: 100px;
            /* Shifting position as requested */
            top: 40px;
            left: 40px;
        }

        .pixel-art {
            width: 50px;
            /* Reduced further to 50px to prevent clipping */
            height: 64px;
            background-image: url('assets/char_sprite.png?v=17');
            background-size: 300px 256px;
            /* Explicit size: 6 cols * 50px, 4 rows * 64px */
            image-rendering: pixelated;
            transform: scaleX(-1) scale(2.5);
            /* Flip horizontally to face Right, Scale 2.5 */
            transform-origin: center;
        }

        /* Frames: 0px to -300px via steps(6) */
        @keyframes sprite-play {
            from {
                background-position-x: 0px;
            }

            to {
                background-position-x: -300px;
            }
        }

        /* Rows */
        .anim-idle {
            background-position-y: 0px;
            animation: sprite-play 1.2s steps(6) infinite;
        }

        .anim-attack {
            background-position-y: -64px;
            /* 2nd Row */
            animation: sprite-play 0.8s steps(6) infinite;
            transform: scaleX(1) scale(2.5);
            /* Flip back to face opposite of Idle */
        }

        .anim-cheer {
            background-position-y: -128px;
            /* 3rd Row */
            animation: sprite-play 0.8s steps(6) infinite;
            transform: scaleX(1) scale(2.2);
            /* Flip back to face opposite of Idle */
        }

        .anim-slime {
            background-position-y: -192px;
            /* 4th Row */
            animation: sprite-play 0.8s steps(6) infinite;

            position: absolute;
            left: 80px;
            /* To the right of the hero */
            top: 20px;
            filter: hue-rotate(0deg);
        }



        .taking-damage {
            animation: flash 0.2s infinite;
        }

        @keyframes flash {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.2;
            }

            100% {
                opacity: 1;
            }
        }

        /* Filter Compact Styles */
        .pos-filter-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: nowrap;
            overflow-x: auto;
            /* Allow scroll on very small screens, but aim for single line */
            white-space: nowrap;
        }

        .filter-label {
            font-weight: bold;
            font-size: 14px;
            color: #555;
            margin-right: 5px;
        }

        .pos-checkbox-item {
            font-size: 13px;
            /* Smaller font */
            color: #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            /* Tight gap between box and text */
        }

        /* --- MOBILE RESPONSIVE STYLES --- */
        @media (max-width: 768px) {

            /* 1. Container & Layout */
            .container {
                width: 95%;
                padding: 15px;
                /* Reduce padding to save space */
                margin: 10px auto;
            }

            /* 2. Stack Cards Vertically */
            .cards-area {
                flex-direction: column;
                /* Stack top-to-bottom */
                gap: 15px;
                align-items: stretch;
                /* Cards take full width */
            }

            .card {
                width: 100%;
                /* Full width */
                min-height: 160px;
                /* Slightly shorter default */
            }

            .card .card-content {
                font-size: 28px;
                /* Slightly smaller text for long words */
            }

            /* 3. Adjust Header */
            .header {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
                margin-top: 50px;
                /* Space for EXP/Stats at top */
            }

            /* Right Header Controls (Mode, etc) */
            .header>div:last-child {
                width: 100%;
                display: flex;
                flex-direction: column;
                /* Stack auto-toggles above modes */
                align-items: flex-start !important;
                position: relative;
                /* For absolute character positioning inside */
            }

            /* Mode Buttons: 2x2 Grid on Left (65% width) */
            .mode-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr;
                /* 2 cols */
                gap: 8px;
                width: 65%;
                /* Leave 35% for character */
                margin-top: 10px;
            }

            .mode-btn {
                flex: unset;
                width: auto;
                min-width: unset;
                height: 50px;
                /* Uniform height */
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                font-size: 13px;
            }

            /* Hide counts if too cramped, or keep small */
            .mode-count {
                font-size: 11px;
            }

            /* Character: Absolute Right of Mode Buttons */
            .rpg-inline {
                position: absolute;
                bottom: 0px;
                /* Align bottom with buttons */
                right: 0px;
                /* Stick to right edge */
                top: auto;
                left: auto;
                transform: scale(0.65);
                transform-origin: bottom right;
                margin-bottom: 0;
                z-index: 50;
                pointer-events: none;
            }

            /* 4. EXP & Stats: Keep at Top Left */
            .stats-absolute {
                transform: scale(0.85);
                top: 10px;
                left: 10px;
                transform-origin: top left;
                z-index: 100;
                width: auto;
            }

            /* Level Selector: Move DOWN below Stats to prevent overlap */
            .level-selector {
                flex-direction: row;
                flex-wrap: nowrap;
                justify-content: flex-end;
                gap: 3px;
                /* Even tighter gap */
                padding-right: 0px;
                overflow-x: auto;
                /* Allow scroll if needed */
                padding-bottom: 5px;
                position: absolute;
                top: 60px;
                /* NEW: Reverted to 60px */
                right: 5px;
                /* Slightly more space on right */
                width: auto;
                max-width: 100%;
                /* Ensure it doesn't overflow screen width logically */
                margin: 0;
            }

            /* Compact Level Buttons for Mobile */
            .level-selector .level-btn {
                padding: 4px 8px;
                /* Extremely compact vertical/horizontal */
                font-size: 11px;
                /* Smaller text */
                white-space: nowrap;
                min-width: unset;
                /* Remove any min-width */
            }

            /* Fix Container padding to account for TALLER fixed header zone */
            .container {
                width: 95%;
                padding: 15px;
                padding-top: 90px;
                /* NEW: Adjusted to 90px (User Req: -20px further) */
                margin: 0 auto;
            }

            /* Compact Level Buttons for Mobile */
            .level-selector .level-btn {
                padding: 4px 8px;
                font-size: 11px;
                white-space: nowrap;
                min-width: unset;
            }

            /* Remove huge header margin on mobile */
            .header {
                margin-bottom: 5px;
            }

            /* Adjust Progress Bar Section */
            .progress-section {
                margin-top: 20px;
            }

            /* 5. Filter Scroll */
            .pos-filter-container {
                -webkit-overflow-scrolling: touch;
                padding-bottom: 5px;
            }
        }

        /* Trial Overlay Styles */
        .trial-overlay {
            position: fixed;
            top: 0;
            /* Added top:0 to ensure full coverage */
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }

        .trial-content {
            background: #2d3436;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 400px;
        }

        .trial-title {
            font-size: 24px;
            margin-bottom: 20px;
            color: #ff7675;
            font-weight: bold;
        }

        .trial-message {
            margin-bottom: 30px;
            line-height: 1.6;
            color: #dfe6e9;
        }

        .unlock-input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 8px;
            border: 1px solid #636e72;
            background: #b2bec3;
            color: #2d3436;
            font-size: 16px;
            text-align: center;
        }

        .unlock-btn {
            background: #0984e3;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: background 0.3s;
        }

        .unlock-btn:hover {
            background: #74b9ff;
        }

        .trial-links {
            margin-top: 20px;
            font-size: 14px;
            color: #b2bec3;
        }

        .trial-links a {
            color: #74b9ff;
            text-decoration: none;
        }

        /* Trial Timer UI */
        .trial-timer {
            font-size: 14px;
            color: #ff7675;
            font-weight: bold;
            background: rgba(255, 118, 117, 0.1);
            padding: 5px 10px;
            border-radius: 12px;
            border: 1px solid #ff7675;
            display: none;
            /* Hidden by default, shown if trial is active */
            white-space: nowrap;
        }

        /* Character Level "Chocon" Display */
        .char-level-display {
            position: absolute;
            top: -20px;
            /* Float above */
            right: 0px;
            /* Centered visually above right-aligned character */
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            color: #667eea;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
            white-space: nowrap;
            pointer-events: none;
            /* Animation for cute float */
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-3px);
            }
        }


        /* --- SIMPLE MODE STYLES --- */
        body.simple-mode .header,
        body.simple-mode .level-selector,
        body.simple-mode .header-controls,
        body.simple-mode .stats-absolute,
        body.simple-mode .simple-switch-container,
        body.simple-mode #trialTimerDisplay,
        body.simple-mode .pos-filter-container,
        body.simple-mode .progress-section,
        body.simple-mode .mobile-progress-wrapper,
        body.simple-mode .random-notice {
            display: none !important;
        }

        body.simple-mode .container {
            margin-top: 60px;
            /* Reset reduced padding */
            max-width: 600px;
            /* Keep it focused */
        }

        body.simple-mode #exitSimpleModeBtn {
            display: block !important;
        }

        body.simple-mode .cards-area {
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <!-- Trial Lock Screen -->
    <!-- TRIAL_START -->
    <div id="trialOverlay" class="trial-overlay">
        <!-- ... content ... -->
        <div class="trial-content">
            <div class="trial-title">‚è≥ Êú¨Êó•„ÅÆ„Éó„É¨„Ç§ÊôÇÈñì„ÅØÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü</div>
            <div class="trial-message">
                ÁÑ°ÊñôÁâà„ÅØ1Êó•10ÂàÜ„Åæ„Åß„Éó„É¨„Ç§ÂèØËÉΩ„Åß„Åô„ÄÇ<br>
                Á∂ö„Åç„ÅØÊòéÊó•„Åæ„ÅüÈÅä„Çì„Åß„Åè„Å†„Åï„ÅÑÔºÅ<br>
                <br>
                <strong>Âà∂Èôê„ÇíËß£Èô§„Åô„Çã„Å´„ÅØÔºü</strong><br>
                Note„É°„É≥„Éê„Éº„Ç∑„ÉÉ„Éó„ÅÆÂêàË®ÄËëâ„ÇíÂÖ•Âäõ„Åô„Çã„Åã„ÄÅ<br>
                ÂÆåÂÖ®Áâà„ÇíË≥ºÂÖ•„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
            </div>
            <input type="password" id="unlockPassword" class="unlock-input" placeholder="ÂêàË®ÄËëâ„ÇíÂÖ•Âäõ">
            <button class="unlock-btn" onclick="unlockGame()">Ëß£Èô§„Åô„Çã</button>
            <button onclick="document.getElementById('trialOverlay').style.display = 'none';"
                style="margin-top: 10px; background: transparent; border: none; color: #999; text-decoration: underline; cursor: pointer;">Èñâ„Åò„Çã</button>

            <div class="trial-links" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                <a href="https://note.com/tenioha_eng/n/n823dfa17b5c7?sub_rt=share_pw" target="_blank"
                    style="color: #74b9ff; text-decoration: none; font-weight: bold; border: 1px solid #74b9ff; padding: 10px; border-radius: 8px;">
                    „É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóÔºà„Çµ„Éñ„Çπ„ÇØÔºâ„ÅßËß£Èô§„Ç≠„Éº„ÇíÂÖ•Êâã
                </a>
                <a href="https://note.com/tenioha_eng/n/n84f2f394b674?sub_rt=share_pw" target="_blank"
                    style="color: #fab1a0; text-decoration: none; font-weight: bold; border: 1px solid #fab1a0; padding: 10px; border-radius: 8px;">
                    ÂÆåÂÖ®ÁâàÔºàË≤∑„ÅÑÂàá„ÇäÔºâ„ÇíË≥ºÂÖ•„Åô„Çã
                </a>
            </div>
        </div>
    </div>
    <!-- TRIAL_END -->

    <div class="container" style="position: relative;">
        <!-- Stats (Moved from Header) -->
        <!-- Stats (Moved from Header) -->
        <!-- Simple Mode Switch (Top Left) -->
        <div class="simple-switch-container" style="position: absolute; top: 15px; left: 15px; z-index: 200;">
            <button class="simple-mode-btn" id="simpleModeBtn" onclick="openSimpleModeModal()"
                style="background: #fff; border: 1px solid #ddd; padding: 5px 10px; border-radius: 20px; font-size: 12px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 5px; color: #555; font-weight: bold;">
                üì± „Ç∑„É≥„Éó„É´„É¢„Éº„Éâ
            </button>
        </div>

        <!-- Top Right Controls (Upload) -->
        <div class="header-controls">
            <div id="trialTimerDisplay" class="trial-timer">ÊÆã„Çä 10:00</div>
            <button class="icon-btn" id="helpBtn" title="ÈÅä„Å≥Êñπ" style="margin-left: 10px;">‚ùì</button>
        </div>


        <div class="level-selector" id="levelContainer">
            <button class="level-btn" data-level="junior">üî∞ ‰∏≠Â≠¶</button>
            <button class="level-btn active" data-level="basic">üìö Âü∫Á§é</button>
            <button class="level-btn" data-level="daily">üé¨ Ê®ôÊ∫ñ</button>
            <button class="level-btn" data-level="exam1">üìñ ÂèóÈ®ì</button>
            <button class="level-btn" id="wordbookBtn" style="background: linear-gradient(135deg, #6c5ce7, #a29bfe);">
                <span class="pc-text">üìò ÂçòË™ûÂ∏≥</span>
                <span class="mobile-text">ÂçòË™ûÂ∏≥</span>
            </button>
        </div>

        <!-- PC Progress Bar (Original) - Hidden on Mobile -->
        <div class="progress-section pc-only">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <div class="title-display">Áß∞Âè∑: <span id="currentTitle" class="js-current-title title-value">Ë¶ãÁøí„ÅÑ</span>
                </div>
                <div class="progress-text"><span id="progressPercent" class="js-progress-percent">0</span>% ÈÅîÊàê</div>
            </div>
            <div class="progress-bar-bg">
                <div class="progress-bar-fill js-progress-bar-fill" id="progressBar" style="width: 0%;"></div>
            </div>
        </div>

        <div class="header">
            <div class="rpg-inline">
                <div id="enemySlime" class="pixel-art anim-slime" style="opacity: 0;"></div>

                <!-- Gold Display (Above Level) -->
                <div class="char-level-display" style="top: -42px; color: #f1c40f;">
                    üí∞ <span id="points">0</span>
                </div>

                <div class="char-level-display">Lv.<span class="js-vocab-level-value">1</span></div>
                <div id="heroCharacter" class="pixel-art anim-idle"></div>
            </div>
            <div
                style="display: flex; flex-direction: column; gap: 10px; align-items: flex-end; width: 100%; max-width: 400px;">

                <!-- Wrapper for Mobile Layout: Toggles (Left) + Progress (Right) -->
                <div class="mobile-layout-row">
                    <div class="toggle-container" style="display: flex; gap: 15px;">
                        <div class="auto-mode-container" id="autoModeToggle">
                            <div class="auto-checkbox" id="autoCheckbox"></div>
                            <div class="auto-label">
                                <span class="pc-text">ü§ñ „Ç™„Éº„Éà„É¢„Éº„Éâ</span>
                                <span class="mobile-text">„Ç™„Éº„Éà</span>
                            </div>
                        </div>
                        <div class="auto-mode-container" id="randomToggle">
                            <div class="auto-checkbox checked" id="randomCheckbox"></div>
                            <div class="auto-label">
                                <span class="pc-text">üîÄ „É©„É≥„ÉÄ„É†Âá∫È°å</span>
                                <span class="mobile-text">„É©„É≥„ÉÄ„É†</span>
                            </div>
                        </div>
                    </div>

                    <!-- Mobile Progress Bar (New) - Visible only on Mobile -->
                    <div class="mobile-progress-wrapper mobile-only" style="display: none;">
                        <!-- Level Display -->
                        <div class="level-display" style="font-weight: bold; color: #666; margin-bottom: 2px;">
                            Lv. <span class="js-local-level-value">1</span>
                        </div>

                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                            <div class="title-display">Áß∞Âè∑: <span class="js-current-title title-value">Ë¶ãÁøí„ÅÑ</span></div>
                            <div class="progress-text"><span class="js-progress-percent">0</span>% ÈÅîÊàê</div>
                        </div>
                        <div class="progress-bar-bg" style="margin-top: 2px;">
                            <div class="progress-bar-fill js-progress-bar-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="random-notice" id="randomNotice" style="display: none;">„É©„É≥„ÉÄ„É†Âá∫È°å‰∏≠„ÄÇÂá∫È°åÁØÑÂõ≤„ÇíÈÅ∏Êäû„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</span>
                    <div class="mode-buttons">
                        <button class="mode-btn unlearned active" data-mode="unlearned" id="unlearnedBtn">
                            <span>üìù Êú™Â≠¶Áøí</span>
                            <span class="mode-count" id="unlearnedCount">0</span>
                        </button>
                        <button class="mode-btn learned" data-mode="learned" id="learnedBtn">
                            <span>‚úÖ ÂæóÊÑè</span>
                            <span class="mode-count" id="learnedCount">0</span>
                        </button>
                        <button class="mode-btn perfect" data-mode="perfect" id="perfectBtn">
                            <span>üèÜ ÂÆåÁíß</span>
                            <span class="mode-count" id="perfectCount">0</span>
                        </button>
                        <button class="mode-btn weak" data-mode="weak" id="weakBtn">
                            <span>üìö Ëã¶Êâã</span>
                            <span class="mode-count" id="weakCount">0</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <style>
            .mobile-text {
                display: none;
            }

            .pc-text {
                display: inline;
            }

            .pc-only {
                display: block;
            }

            .mobile-only {
                display: none;
            }

            @media (max-width: 768px) {
                .mobile-text {
                    display: inline;
                }

                .pc-text {
                    display: none;
                }

                .pc-only {
                    display: none !important;
                }

                .mobile-only {
                    display: flex !important;
                }

                /* Stack toggles vertically on mobile */
                .toggle-container {
                    flex-direction: column;
                    gap: 5px !important;
                    align-items: flex-start;
                    /* Left-align start */
                }

                /* Force equal width for toggles on mobile to align right edges too */
                .toggle-container .auto-mode-container {
                    min-width: 85px;
                    justify-content: flex-start;
                }

                /* Squeeze "Random" text to fit same width as "Auto" */
                #randomToggle .mobile-text {
                    font-size: 11px;
                    /* Smaller font for Random */
                    letter-spacing: -1px;
                    /* Tighter letter spacing */
                }

                /* Mobile Layout Row: Toggles + Progress Bar */
                .mobile-layout-row {
                    display: flex;
                    gap: 15px;
                    /* Space between toggles and progress bar */
                    align-items: center;
                    /* Vertically center them */
                    width: 100%;
                }

                /* Mobile Progress Bar Styling */
                /* Mobile Progress Bar Styling */
                .mobile-progress-wrapper {
                    flex-grow: 1;
                    /* VARIABLE WIDTH - Fills remaining space */
                    display: flex;
                    flex-direction: column;
                    justify-content: center;

                    /* PC Style White Frame */
                    background: white;
                    padding: 6px 12px;
                    /* Compact padding */
                    border-radius: 10px;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);

                    /* No Transform Scaling - Use natural sizing */
                    width: auto;
                    min-width: 0;
                    /* Allow shrinking */
                }

                /* Compact text sizes for mobile progress elements */
                .mobile-progress-wrapper .title-display,
                .mobile-progress-wrapper .progress-text,
                .mobile-progress-wrapper .level-display {
                    font-size: 10px !important;
                }

                .mobile-progress-wrapper .title-value {
                    font-size: 11px !important;
                }

                .mobile-progress-wrapper .progress-bar-bg {
                    height: 8px !important;
                    /* Thinner bar */
                    border-radius: 4px !important;
                }
            }
        </style>

        <div class="pos-filter-container">
            <div class="filter-label">„Éï„Ç£„É´„Çø:</div>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Âêç" checked> ÂêçË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Âãï" checked> ÂãïË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="ÂΩ¢" checked> ÂΩ¢ÂÆπË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="ÂâØ" checked> ÂâØË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Âä©" checked> Âä©ÂãïË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Ââç" checked> ÂâçÁΩÆË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Êé•" checked> Êé•Á∂öË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="‰ª£" checked> ‰ª£ÂêçË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="other" checked> „Åù„ÅÆ‰ªñ
            </label>
        </div>

        <div id="addWordsContainer" style="text-align: center; display: none; margin-bottom: 20px;">
            <button class="add-words-btn" id="addWordsBtn">‚ûï Ê¨°„ÅÆ„Çª„ÉÉ„Éà„ÇíËøΩÂä†Ôºà„É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºâ</button>
        </div>

        <div class="main-content">
            <div class="cards-section">
                <div class="cards-area" id="cardsArea">
                    <div class="card vocab-card" id="vocabCard">
                        <div class="card-label">Ëã±ÂçòË™û„Ç´„Éº„Éâ</div>
                        <div class="card-content" id="vocabWord">„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ</div>
                    </div>

                    <div class="card meaning-card" id="meaningCard">
                        <div class="card-label">ÊÑèÂë≥„Ç´„Éº„Éâ</div>
                        <div class="card-front">
                            <div class="card-content">‚ùì</div>
                        </div>
                        <div class="card-back">
                            <div class="card-content" id="meaningText">ÊÑèÂë≥</div>
                        </div>
                    </div>
                </div>

                <div class="example-area" id="exampleArea">
                    <button class="speaker-btn" id="speakerBtn">üîä</button>
                    <div class="example-text">
                        <div class="example-label">‰æãÊñá</div>
                        <div class="example-sentence" id="exampleSentence">„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ</div>
                    </div>
                    <button class="undo-btn" id="undoBtn" onclick="undoLastAction()" disabled>‚Ü©Ô∏è Êàª„Çã</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Import External Vocabulary Data -->
    <!-- Import External Vocabulary Data -->
    <script src="data/vocabulary.js?v=2"></script>


    <script>
        let gameState = {
            points: 0,
            currentMode: 'unlearned',
            currentLevel: 'basic',
            currentWordIndex: 0,
            currentWord: null,
            wordStates: {},
            weakWordProgress: {},
            learnedWordIntervals: {},
            globalQuestionCount: 0,
            sessionStartTime: Date.now(),
            meaningCardFlipped: false,
            isReviewWord: false,
            questionCount: 0,
            autoMode: false,
            randomMode: true,
            posFilters: ['Âêç', 'Âãï', 'ÂΩ¢', 'ÂâØ', 'Âä©', 'Ââç', 'Êé•', '‰ª£', 'other'], // Active POS filters
            vocabLevel: 1,
            wordsLearned: 0 // Total words moved from unlearned
        };

        // Initialize with default or empty
        let vocabularyDatabase = (typeof DEFAULT_VOCABULARY !== 'undefined') ? JSON.parse(JSON.stringify(DEFAULT_VOCABULARY)) : {
            basic: [],
            daily: [],
            exam1: [],
            exam2: [],
            junior: []
        };

        // Merge Junior data if loaded via temp variable


        let vocabulary = [];
        let autoTimer = null;
        let gameStateHistory = []; // Stack to store previous states

        // Save current state to history (Max 1 step for now)
        function saveState() {
            // Deep copy gameState
            const stateSnapshot = JSON.parse(JSON.stringify(gameState));
            gameStateHistory.push(stateSnapshot);
            // Limit history to 1 step as per requirement (can be increased)
            if (gameStateHistory.length > 5) {
                gameStateHistory.shift();
            }
            updateUndoButton();
        }

        // Restore last state
        function undoLastAction() {
            if (gameStateHistory.length === 0) return;

            const previousState = gameStateHistory.pop();
            gameState = previousState;

            // Restore UI
            showWord(gameState.currentWord);
            updateDisplay();
            updateUndoButton();

            // Re-apply current mode button styles if needed
            updateModeButtons();
        }

        function updateUndoButton() {
            const btn = document.getElementById('undoBtn');
            if (btn) {
                btn.disabled = gameStateHistory.length === 0;
            }
        }

        // --- Trial System Config ---
        const TRIAL_CONFIG = {
            LIMIT_SECONDS: 600, // 10 minutes
            PASSWORD: "appleisbanana",
            STORAGE_KEY: "vocabGame_trialState_v2" // Changed key to force reset/migration if needed, or just keep same
        };

        let trialState = {
            unlocked: false,
            lastPlayDate: null,
            playTimeSeconds: 0
        };

        let lastTickTime = Date.now();

        // Initialize Trial
        function initTrialSystem() {
            const savedTrial = localStorage.getItem(TRIAL_CONFIG.STORAGE_KEY);

            // Get Current Date in JST (Japan Standard Time)
            const jstFormatter = new Intl.DateTimeFormat('en-CA', {
                timeZone: 'Asia/Tokyo',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
            const today = jstFormatter.format(new Date());

            if (savedTrial) {
                try {
                    const parsed = JSON.parse(savedTrial);
                    trialState = { ...trialState, ...parsed };
                } catch (e) {
                    console.error("Trial save corrupted", e);
                }
            }

            // Daily Reset (JST Midnight)
            if (trialState.lastPlayDate !== today) {
                trialState.lastPlayDate = today;
                if (!trialState.unlocked) {
                    trialState.playTimeSeconds = 0; // Reset time if not unlocked
                }
                saveTrialState();
            }

            // Initialize Tick Time
            lastTickTime = Date.now();

            // Toggle UI based on state
            updateTrialUI();

            // Check if already over limit
            checkTrialLimit();

            // Start Timer Loop
            setInterval(updateTrialTimer, 1000);
        }

        function saveTrialState() {
            localStorage.setItem(TRIAL_CONFIG.STORAGE_KEY, JSON.stringify(trialState));
        }

        function updateTrialTimer() {
            if (trialState.unlocked) {
                updateTrialUI(); // Ensure UI is hidden
                return;
            }

            const now = Date.now();
            const deltaSeconds = (now - lastTickTime) / 1000;
            lastTickTime = now;

            // Only count logical time flow. 
            // If delta is huge (e.g. computer slept for 10 days), it will add that time.
            // This effectively solves "background tab throttling" because next tick will just add the large difference.

            if (deltaSeconds > 0) {
                trialState.playTimeSeconds += deltaSeconds;
            }

            // Save every ~5 seconds (or if huge jump)
            if (Math.floor(trialState.playTimeSeconds) % 5 === 0 || deltaSeconds > 5) {
                saveTrialState();
            }

            updateTrialUI();
            checkTrialLimit();
        }

        function updateTrialUI() {
            const timerDisplay = document.getElementById('trialTimerDisplay');
            if (!timerDisplay) return;

            if (trialState.unlocked) {
                timerDisplay.style.display = 'none';
                return;
            }

            timerDisplay.style.display = 'block';

            const remaining = Math.max(0, TRIAL_CONFIG.LIMIT_SECONDS - Math.floor(trialState.playTimeSeconds));
            const m = Math.floor(remaining / 60);
            const s = Math.floor(remaining % 60);

            // Format mm:ss
            timerDisplay.textContent = `ÊÆã„Çä ${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;

            // Warning color if low
            if (remaining < 60) {
                timerDisplay.style.color = '#d63031';
                timerDisplay.style.borderColor = '#d63031';
                timerDisplay.style.backgroundColor = 'rgba(214, 48, 49, 0.1)';
            }
        }

        function checkTrialLimit() {
            if (trialState.unlocked) return;

            if (trialState.playTimeSeconds >= TRIAL_CONFIG.LIMIT_SECONDS) {
                showLockScreen();
            }
        }

        function showLockScreen() {
            const overlay = document.getElementById('trialOverlay');
            if (overlay.style.display !== 'flex') {
                overlay.style.display = 'flex';
                // Stop any game audio or timers here if needed
                clearAutoTimer();
            }
        }

        function unlockGame() {
            const input = document.getElementById('unlockPassword');
            const val = input.value.trim();

            if (val === TRIAL_CONFIG.PASSWORD) {
                alert("Ëß£Èô§ÊàêÂäüÔºÅ\nÁÑ°Âà∂Èôê„É¢„Éº„Éâ„Åß„Éó„É¨„Ç§„Åß„Åç„Åæ„Åô„ÄÇ");
                trialState.unlocked = true;
                saveTrialState();
                updateTrialUI(); // Update UI to hide timer

                document.getElementById('trialOverlay').style.display = 'none';

                // Analytics Placeholder
                if (typeof gtag === 'function') {
                    gtag('event', 'unlock_success', {
                        'event_category': 'engagement',
                        'event_label': 'password_unlock'
                    });
                }
            } else {
                alert("„Éë„Çπ„ÉØ„Éº„Éâ„ÅåÈÅï„ÅÑ„Åæ„Åô„ÄÇ\nNote„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ");
                input.value = "";

                // Analytics Placeholder
                if (typeof gtag === 'function') {
                    gtag('event', 'unlock_failure');
                }
            }
        }

        function init() {
            loadGame();

            // Ensure compatibility with old saves if level names changed
            if (!vocabularyDatabase[gameState.currentLevel]) {
                gameState.currentLevel = 'basic';
            }

            document.addEventListener('click', () => {
                // Initialize audio context on first interaction
                if (!audioWakeLockSet) {
                    enableAudioStayAwake();
                }
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }, { once: true }); // Only needs to run once

            setupEventListeners();
            setupPOSFilters(); // Need to call this to attach listeners to new checkboxes

            // MUST load vocabulary before updateDisplay
            if (vocabulary.length === 0 && vocabularyDatabase[gameState.currentLevel].length > 0) {
                loadVocabularyForLevel();
                // If states are empty, init them
                if (Object.keys(gameState.wordStates).filter(k => k.startsWith(gameState.currentLevel)).length === 0) {
                    initializeWordStates();
                }
            }

            updateDisplay();
            showNextWord();
        }

        function setupEventListeners() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', handleFileUpload);
            }

            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const level = btn.dataset.level;
                    switchLevel(level);
                });
            });

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (btn.disabled) return;
                    const mode = btn.dataset.mode;
                    gameState.currentMode = mode;
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    showNextWord();
                    saveGame();
                });
            });

            document.getElementById('autoModeToggle').addEventListener('click', () => {
                gameState.autoMode = !gameState.autoMode;
                const checkbox = document.getElementById('autoCheckbox');
                if (gameState.autoMode) {
                    checkbox.classList.add('checked');
                    startAutoTimer();
                } else {
                    checkbox.classList.remove('checked');
                    clearAutoTimer();
                }
            });

            document.getElementById('randomToggle').addEventListener('click', () => {
                gameState.randomMode = !gameState.randomMode;
                const checkbox = document.getElementById('randomCheckbox');
                if (gameState.randomMode) {
                    checkbox.classList.add('checked');
                } else {
                    checkbox.classList.remove('checked');
                }
                updateModeButtons();
                showNextWord();
                saveGame();
            });

            // POS Filter checkboxes
            setupPOSFilters();
            document.getElementById('speakerBtn').addEventListener('click', () => {
                if (gameState.currentWord) {
                    speakWord(gameState.currentWord.word);
                }
            });

            document.getElementById('addWordsBtn').addEventListener('click', addNextWordSet);

            setupCardListeners();
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                parseCSV(text);
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            const lines = text.split('\n');
            const level = gameState.currentLevel;
            vocabularyDatabase[level] = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // CSV format: word, meaning, pos, example, set
                // If 6 columns, assume 6th is phrase, otherwise fallback
                const parts = line.split(',');
                if (parts.length >= 5) {
                    const wordObj = {
                        word: parts[0].trim(),
                        meaning: parts[1].trim(),
                        pos: parts[2].trim(),
                        example: parts[3].trim(),
                        set: parseInt(parts[4].trim())
                    };

                    if (parts.length >= 6) {
                        wordObj.phrase = parts[5].trim();
                    } else {
                        // Fallback logic if phrase is missing
                        wordObj.phrase = wordObj.meaning;
                    }

                    vocabularyDatabase[level].push(wordObj);
                }
            }

            loadVocabularyForLevel();
            initializeWordStates();
            document.getElementById('fileInfo').textContent = `‚úÖ ${vocabularyDatabase[level].length}Ë™û„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü`;
            showNextWord();
            saveGame();
        }

        function switchLevel(level) {
            gameState.currentLevel = level;
            document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));

            const targetBtn = document.querySelector(`.level-btn[data-level="${level}"]`);
            if (targetBtn) {
                targetBtn.classList.add('active');
            } else if (level.startsWith('selection')) {
                // Highlight Wordbook button if we are in a special wordbook mode
                const wbBtn = document.getElementById('wordbookBtn');
                if (wbBtn) wbBtn.classList.add('active');
            }

            loadVocabularyForLevel();
            initializeWordStates();
            updateDisplay();
            showNextWord();
            saveGame();
        }

        function loadVocabularyForLevel() {
            if (gameState.currentLevel.startsWith('selection')) {
                const rawWords = vocabularyDatabase[gameState.currentLevel] || [];
                vocabulary = rawWords.map(v => {
                    if (v.ref && v.ref !== gameState.currentLevel) {
                        let refCategory = v.ref;
                        let refWordText = v.word;

                        if (v.ref.includes(':')) {
                            const parts = v.ref.split(':');
                            refCategory = parts[0];
                            refWordText = parts[1];
                        }

                        const refArray = vocabularyDatabase[refCategory];
                        if (refArray) {
                            // Find match by word text
                            const refWord = refArray.find(r => r.word === refWordText);
                            if (refWord) {
                                // Merge referenced data (meanings, examples) but keep selection-specific metadata (set, id)
                                return {
                                    ...v,
                                    meaning: refWord.meaning,
                                    phrase: refWord.phrase,
                                    example: refWord.example,
                                    pos: refWord.pos
                                };
                            }
                        }
                    }
                    return v;
                }).filter(v => {
                    // Always include if set is not a number (e.g. "system") or matches current level logic
                    if (typeof v.set !== 'number') return true;
                    return v.set <= gameState.vocabLevel;
                });
            } else {
                vocabulary = vocabularyDatabase[gameState.currentLevel].filter(v => {
                    if (typeof v.set !== 'number') return true;
                    return v.set <= gameState.vocabLevel;
                });
            }
        }

        function getWordKey(word, level) {
            // Generalize shared progress for any word with a reference
            if (word.ref && word.ref !== level) {
                let refCategory = word.ref;
                let refWordText = word.word;

                if (word.ref.includes(':')) {
                    const parts = word.ref.split(':');
                    refCategory = parts[0];
                    refWordText = parts[1];
                }

                return `${refCategory}_${refWordText}`;
            }
            return `${level}_${word.word}`;
        }

        function initializeWordStates() {
            vocabulary.forEach(v => {
                const key = getWordKey(v, gameState.currentLevel);
                if (!gameState.wordStates[key]) {
                    gameState.wordStates[key] = 'unlearned';
                }
            });
        }

        function saveGame() {
            const data = {
                points: gameState.points,
                wordStates: gameState.wordStates,
                weakWordProgress: gameState.weakWordProgress,
                learnedWordIntervals: gameState.learnedWordIntervals,
                globalQuestionCount: gameState.globalQuestionCount,
                currentLevel: gameState.currentLevel,
                currentMode: gameState.currentMode,
                vocabLevel: gameState.vocabLevel,
                questionCount: gameState.questionCount
            };
            localStorage.setItem('vocabClickerSave', JSON.stringify(data));
        }

        function loadGame() {
            const saved = localStorage.getItem('vocabClickerSave');
            if (saved) {
                const data = JSON.parse(saved);
                gameState = { ...gameState, ...data };
            }
        }

        function startPlayTimeCounter() {
            gameState.sessionStartTime = Date.now();
            playTimeInterval = setInterval(updatePlayTime, 1000);
        }

        function updatePlayTime() {
            const elapsed = Date.now() - gameState.sessionStartTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('playTime').textContent =
                `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function setupPOSFilters() {
            const checkboxes = document.querySelectorAll('.pos-filter');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    updatePOSFilters();
                    showNextWord();
                    saveGame();
                });
            });
        }

        function updatePOSFilters() {
            const checkboxes = document.querySelectorAll('.pos-filter');
            gameState.posFilters = [];
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    gameState.posFilters.push(checkbox.dataset.pos);
                }
            });
        }

        function filterWordsByPOS(words) {
            if (gameState.posFilters.length === 0) return [];
            return words.filter(word => {
                const pos = word.pos || 'other';
                return gameState.posFilters.includes(pos) ||
                    (pos !== 'Âêç' && pos !== 'Âãï' && pos !== 'ÂΩ¢' && pos !== 'ÂâØ' &&
                        pos !== 'Âä©' && pos !== 'Ââç' && pos !== 'Êé•' && pos !== '‰ª£' && gameState.posFilters.includes('other'));
            });
        }

        function checkVocabLevelUp() {
            // Re-calculate World Level
            const categories = ['junior', 'basic', 'daily', 'exam1'];
            let newWorldLevel = 0;
            categories.forEach(cat => {
                newWorldLevel += getCategoryLevel(cat);
            });

            if (newWorldLevel > gameState.vocabLevel) {
                gameState.vocabLevel = newWorldLevel;
                showCoinPopup(`üéâ „ÉØ„Éº„É´„Éâ„É¨„Éô„É´ ${gameState.vocabLevel} „Å´„Ç¢„ÉÉ„ÉóÔºÅ`, true);
            }
            updateVocabLevelDisplay();
        }

        function updateVocabLevelDisplay() {
            document.getElementById('vocabLevelDisplay').textContent = gameState.vocabLevel;
        }

        function getWordsByMode(mode) {
            const modeWords = vocabulary.filter(v => {
                const key = getWordKey(v, gameState.currentLevel);
                return gameState.wordStates[key] === mode;
            });
            return filterWordsByPOS(modeWords);
        }

        function getEligibleLearnedWords() {
            const learnedWords = getWordsByMode('learned');
            const eligibleWords = [];

            for (const word of learnedWords) {
                const key = getWordKey(word, gameState.currentLevel);
                const interval = gameState.learnedWordIntervals[key] || 0;
                const requiredInterval = Math.pow(2, interval) * 12;
                const lastShown = gameState.learnedWordIntervals[`${key}_last`] || 0;

                if (gameState.globalQuestionCount - lastShown >= requiredInterval) {
                    eligibleWords.push(word);
                }
            }

            if (eligibleWords.length === 0 && learnedWords.length > 0) {
                return learnedWords;
            }

            return eligibleWords;
        }

        // Web Audio API Context for keeping hardware awake
        let audioContext = null;
        let audioWakeLockSet = false;

        function enableAudioStayAwake() {
            if (audioWakeLockSet) return;

            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;

                audioContext = new AudioContext();

                // Create a silent oscillator to keep the audio engine active
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.frequency.value = 440; // Frequency doesn't matter much as volume is near zero

                // Extremely low volume (but not zero) to cheat the OS silence detection
                gainNode.gain.value = 0.00001;

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(0);
                audioWakeLockSet = true;
                console.log("Audio Wake Lock engaged.");
            } catch (e) {
                console.error("Audio Wake Lock failed:", e);
            }
        }

        function speakWord(word) {
            // Ensure audio engine is awake
            if (!audioWakeLockSet) {
                enableAudioStayAwake();
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Cancel previous speech
            speechSynthesis.cancel();

            // Small delay to allow cancellation to clear
            setTimeout(() => {
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = 'en-US';

                // Try to select a better voice
                const voices = speechSynthesis.getVoices();
                // Priority list: Google US English, Samantha (iOS/Mac), Microsoft Zira (Win)
                const preferredVoice = voices.find(v => v.name === 'Google US English') ||
                    voices.find(v => v.name === 'Samantha') ||
                    voices.find(v => v.name.includes('Google') && v.lang.startsWith('en')) ||
                    voices.find(v => v.lang === 'en-US');

                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }

                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;

                speechSynthesis.speak(utterance);
            }, 50);
        }

        function showNextWord() {
            gameState.meaningCardFlipped = false;
            clearAutoTimer();

            let words;
            let shouldShowReview = false;
            let reviewType = null;

            if (!gameState.randomMode) {
                words = getWordsByMode(gameState.currentMode);
                gameState.isReviewWord = false;
            } else {
                // NEW: Adaptive Weighted Probability Logic
                const unlearnedWords = getWordsByMode('unlearned');
                const learnedWords = getEligibleLearnedWords();
                const weakWords = getWordsByMode('weak');

                // Weights defaults: Unlearned(75), Learned(10), Weak(15)
                let weightUnlearned = 75;
                let weightLearned = 10;
                let weightWeak = 15;

                const weakCount = weakWords.length;

                // Dynamic Adjustment based on Weak Count
                if (weakCount >= 150) {
                    // Critical: Block new words almost entirely
                    weightUnlearned = 5;
                    weightLearned = 5;
                    weightWeak = 90;
                } else if (weakCount >= 100) {
                    // Warning: High priority on cleanup
                    weightUnlearned = 20;
                    weightLearned = 10;
                    weightWeak = 70;
                } else if (weakCount >= 50) {
                    // Caution: Shift balance
                    weightUnlearned = 50;
                    weightLearned = 10;
                    weightWeak = 40;
                }

                // If a category is empty, set its weight to 0 to avoid selecting it

                if (unlearnedWords.length === 0) weightUnlearned = 0;
                if (learnedWords.length === 0) weightLearned = 0;
                if (weakWords.length === 0) weightWeak = 0;

                const totalWeight = weightUnlearned + weightLearned + weightWeak;

                if (totalWeight === 0) {
                    // Fallback if absolutely nothing is available
                    words = [];
                } else {
                    const r = Math.random() * totalWeight;

                    if (r < weightUnlearned) {
                        words = unlearnedWords;
                        gameState.isReviewWord = false;
                    } else if (r < weightUnlearned + weightLearned) {
                        words = learnedWords;
                        shouldShowReview = true;
                        reviewType = 'learned';
                    } else {
                        words = weakWords;
                        shouldShowReview = true;
                        reviewType = 'weak';
                    }
                }
            }

            gameState.isReviewWord = shouldShowReview;
            gameState.globalQuestionCount++;

            if (words.length === 0) {
                showNoWordsMessage();
                return;
            }

            hideNoWordsMessage();
            gameState.currentWordIndex = Math.floor(Math.random() * words.length);
            const word = words[gameState.currentWordIndex];
            gameState.currentWord = word;

            // MAP POS to Full Name
            const posMap = {
                "Âêç": "ÂêçË©û",
                "Âãï": "ÂãïË©û",
                "ÂΩ¢": "ÂΩ¢ÂÆπË©û",
                "ÂâØ": "ÂâØË©û",
                "Âä©": "Âä©ÂãïË©û",
                "Êé•": "Êé•Á∂öË©û",
                "Ââç": "ÂâçÁΩÆË©û",
                "‰ª£": "‰ª£ÂêçË©û"
            };
            const fullPos = posMap[word.pos] || word.pos;

            // UPDATE: Display POS above Word (Full Name)
            // Visual Adjustment: shift up slightly so the WORD looks centered, not the whole block
            document.getElementById('vocabWord').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; transform: translateY(-10%);">
                    <div style="font-size: 18px; color: #667eea; font-weight: normal; margin-bottom: 5px;">${fullPos}</div>
                    <div style="font-size: 42px; font-weight: bold; line-height: 1.2;">${word.word}</div>
                </div>
            `;

            // UPDATE: Display Meaning (Large) + Minimal Phrase (Small below)

            // Label Idea: Use English "Phrase" in small caps for a cleaner look
            const phraseLabel = `<span style="font-size: 11px; color: #999; text-transform: uppercase; letter-spacing: 1.5px; display: block; margin-bottom: 4px;">PHRASE</span>`;

            // Layout: Meaning (Center/Large) -> Phrase (Below/Small)
            document.getElementById('meaningText').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;">
                    <div style="font-size: 32px; font-weight: bold; color: #333; margin-bottom: 20px;">${word.meaning}</div>
                    ${word.phrase ? `
                        <div style="text-align: center; background: #f8f9fa; padding: 10px 20px; border-radius: 12px; border: 1px solid #eef0f5;">
                            ${phraseLabel}
                            <div style="font-size: 18px; color: #444; font-weight: 500;">${word.phrase}</div>
                        </div>
                    ` : ''}
                </div>
            `;

            document.getElementById('exampleSentence').textContent = word.example;
            document.getElementById('meaningCard').classList.remove('flipped');

            const vocabCard = document.getElementById('vocabCard');
            const existingBadge = vocabCard.querySelector('.review-badge');
            if (existingBadge) existingBadge.remove();

            if (gameState.isReviewWord) {
                const badge = document.createElement('div');
                badge.className = 'review-badge';
                if (reviewType === 'learned') {
                    badge.textContent = 'ÂæóÊÑè';
                    badge.style.backgroundColor = '#4caf50'; // Green
                } else {
                    badge.textContent = 'Ëã¶Êâã';
                    badge.style.backgroundColor = '#f44336'; // Red
                }
                vocabCard.appendChild(badge);
            }

            // DOMÊõ¥Êñ∞Âæå„ÄÅÂ∞ë„ÅóÂæÖ„Å£„Å¶„Åã„ÇâÈü≥Â£∞ÂÜçÁîü
            setTimeout(() => {
                speakWord(word.word);
            }, 200);

            if (gameState.autoMode) {
                startAutoTimer();
            }

            checkLevelUp();
        }

        // NEW: Function to show a SPECIFIC word (for Undo/Restore)
        function showWord(word) {
            if (!word) return;

            // Reset Card State
            gameState.meaningCardFlipped = false;
            document.getElementById('meaningCard').classList.remove('flipped');

            // Map POS
            const posMap = {
                "Âêç": "ÂêçË©û",
                "Âãï": "ÂãïË©û",
                "ÂΩ¢": "ÂΩ¢ÂÆπË©û",
                "ÂâØ": "ÂâØË©û",
                "Âä©": "Âä©ÂãïË©û",
                "Êé•": "Êé•Á∂öË©û",
                "Ââç": "ÂâçÁΩÆË©û",
                "‰ª£": "‰ª£ÂêçË©û"
            };
            const fullPos = posMap[word.pos] || word.pos;

            // Update DOM (MATCHING showNextWord STRUCTURE EXACTLY)
            document.getElementById('vocabWord').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; transform: translateY(-10%);">
                    <div style="font-size: 18px; color: #667eea; font-weight: normal; margin-bottom: 5px;">${fullPos}</div>
                    <div style="font-size: 42px; font-weight: bold; line-height: 1.2;">${word.word}</div>
                </div>
            `;

            // Update Meaning (MATCHING showNextWord STRUCTURE)
            // Label Idea: Use English "Phrase" in small caps for a cleaner look
            const phraseLabel = `<span style="font-size: 11px; color: #999; text-transform: uppercase; letter-spacing: 1.5px; display: block; margin-bottom: 4px;">PHRASE</span>`;

            document.getElementById('meaningText').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;">
                    <div style="font-size: 32px; font-weight: bold; color: #333; margin-bottom: 20px;">${word.meaning}</div>
                    ${word.phrase ? `
                        <div style="text-align: center; background: #f8f9fa; padding: 10px 20px; border-radius: 12px; border: 1px solid #eef0f5;">
                            ${phraseLabel}
                            <div style="font-size: 18px; color: #444; font-weight: 500;">${word.phrase}</div>
                        </div>
                    ` : ''}
                </div>
            `;

            document.getElementById('exampleSentence').textContent = word.example;

            // Re-bind speaker button for this word
            const speakerBtn = document.getElementById('speakerBtn');
            const newBtn = speakerBtn.cloneNode(true);
            speakerBtn.parentNode.replaceChild(newBtn, speakerBtn);

            newBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                speakText(word.example);
            });

            updateProgress();
        }

        function showNoWordsMessage() {
            const cardsArea = document.getElementById('cardsArea');
            const modeNames = {
                'unlearned': 'Êú™Â≠¶Áøí',
                'learned': 'ÂæóÊÑè',
                'perfect': 'ÂÆåÁíß',
                'weak': 'Ëã¶Êâã'
            };
            cardsArea.innerHTML = `<div class="no-words">„Åì„ÅÆ${modeNames[gameState.currentMode] || gameState.currentMode}„É¢„Éº„Éâ„Å´„ÅØÂçòË™û„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>`;
            document.getElementById('exampleArea').style.display = 'none';
        }

        function hideNoWordsMessage() {
            const cardsArea = document.getElementById('cardsArea');
            if (cardsArea.querySelector('.no-words')) {
                cardsArea.innerHTML = `
                    <div class="card vocab-card" id="vocabCard">
                        <div class="card-label">Ëã±ÂçòË™û„Ç´„Éº„Éâ</div>
                        <div class="card-content" id="vocabWord">Loading...</div>
                    </div>
                    <div class="card meaning-card" id="meaningCard">
                        <div class="card-label">ÊÑèÂë≥„Ç´„Éº„Éâ</div>
                        <div class="card-front">
                            <div class="card-content">‚ùì</div>
                        </div>
                        <div class="card-back">
                            <div class="card-content" id="meaningText">ÊÑèÂë≥</div>
                        </div>
                    </div>
                `;
                setupCardListeners();
            }
            document.getElementById('exampleArea').style.display = 'flex';
        }

        function clearAutoTimer() {
            if (autoTimer) {
                clearTimeout(autoTimer);
                autoTimer = null;
            }
        }

        function startAutoTimer() {
            clearAutoTimer();
            autoTimer = setTimeout(() => {
                if (!gameState.meaningCardFlipped && gameState.autoMode) {
                    autoOpenMeaningCard();
                }
            }, 3000);
        }

        function autoOpenMeaningCard() {
            const meaningCard = document.getElementById('meaningCard');
            if (!meaningCard || gameState.meaningCardFlipped) return;

            meaningCard.classList.add('flipped');
            gameState.meaningCardFlipped = true;

            const currentWord = gameState.currentWord;
            if (!currentWord) return;

            const key = getWordKey(currentWord, gameState.currentLevel);
            if (!gameState.isReviewWord && (gameState.currentMode === 'unlearned' || gameState.currentMode === 'weak')) {
                gameState.questionCount++;
            }

            gameState.wordStates[key] = 'weak';

            if (gameState.weakWordProgress[key]) {
                delete gameState.weakWordProgress[key];
            }

            const basePoints = 2;
            const finalPoints = basePoints * gameState.vocabLevel;
            gameState.points += finalPoints;

            showCoinPopup(finalPoints);
            updateDisplay();
            animateCharacter();
            saveGame();

            autoTimer = setTimeout(() => {
                if (gameState.autoMode) {
                    showNextWord();
                }
            }, 2000);
        }

        function setupCardListeners() {
            const vocabCard = document.getElementById('vocabCard');
            const meaningCard = document.getElementById('meaningCard');

            if (vocabCard) {
                vocabCard.addEventListener('click', handleVocabCardClick);
            }

            if (meaningCard) {
                meaningCard.addEventListener('click', handleMeaningCardClick);
            }
        }

        function handleVocabCardClick() {
            const currentWord = gameState.currentWord;
            if (!currentWord) return;

            clearAutoTimer();

            // Ignore click if card is already flipped (user should click Next or Meaning card)
            // Actually, if flipped, clicking vocab card usually means "Next" in this design?
            // User said: "Click vocab card = Correct".
            // If already flipped, maybe "Correct" doesn't make sense anymore because they saw the answer.
            // But let's assume clicking Vocab Card (Front) is the primary "I know this" action.
            // If flipped, it's hidden behind checks usually. 
            // In the provided code, vocabCard is FRONT. meaningCard is BACK.
            // If flipped, Vocab Card is HIDDEN.
            // So this handler only fires if NOT flipped.

            if (gameState.meaningCardFlipped) {
                // Should not happen if UI hides it, but safety:
                showNextWord();
                return;
            }

            // Save state for Undo
            saveState();

            const key = getWordKey(currentWord, gameState.currentLevel);
            let basePoints = 1;
            let msg = "";

            // LOGIC: Unlearned -> Perfect, Weak -> Learned, Learned -> Perfect, Perfect -> Perfect
            const currentState = gameState.wordStates[key];

            if (currentState === 'unlearned') {
                gameState.wordStates[key] = 'perfect';
                gameState.wordsLearned++;
                checkLevelUp();
            } else if (currentState === 'weak') {
                gameState.wordStates[key] = 'learned';
                basePoints = 2; // User Request: 2 points for weak (Priority)
                msg = "‚úÖ ÂÖãÊúçÔºÅ";
                if (gameState.weakWordProgress[key]) delete gameState.weakWordProgress[key];
                gameState.learnedWordIntervals[key] = 0;
                gameState.learnedWordIntervals[`${key}_last`] = gameState.globalQuestionCount;
            } else if (currentState === 'learned') {
                gameState.wordStates[key] = 'perfect';
                basePoints = 1; // Default 1
                msg = "üèÜ ÂÆåÁíß„Éû„Çπ„Çø„ÉºÔºÅ";
            } else if (currentState === 'perfect') {
                // Stay perfect
                basePoints = 1; // Default 1
                msg = "‚ú® ÂÆåÁíßÁ∂≠ÊåÅÔºÅ";
            } else {
                // Fallback
                gameState.wordStates[key] = 'perfect';
                basePoints = 1;
            }

            const finalPoints = basePoints * gameState.vocabLevel;
            gameState.points += finalPoints;

            // RPG Animation Trigger
            // RPG Animation Trigger
            if (currentState === 'weak') {
                playAnimation('attack'); // Weakness Overcome -> Battle
                //} else if (msg.includes('ÂÆåÁíß')) {
                //    // Perfect -> Victory
                //    playAnimation('victory');
            } else {
                playAnimation('idle'); // Standard
            }

            showCoinPopup(finalPoints); // Optionally show text? Currently logic only shows number.

            updateDisplay();
            showNextWord();
            animateCharacter();
            saveGame();
        }

        function handleMeaningCardClick(e) {
            const card = e.currentTarget;
            clearAutoTimer();

            if (!gameState.meaningCardFlipped) {
                // Save state for Undo
                saveState();

                // Flip = Incorrect / Check
                card.classList.add('flipped');
                gameState.meaningCardFlipped = true;

                const currentWord = gameState.currentWord;
                if (!currentWord) return;

                const key = getWordKey(currentWord, gameState.currentLevel);
                const currentState = gameState.wordStates[key];

                // LOGIC: Learned -> Weak. Unlearned -> Weak. Perfect -> Learned (Soft landing).

                if (currentState === 'perfect') {
                    gameState.wordStates[key] = 'learned';
                    // Reset learned interval as it's a "new" learned word effectively
                    gameState.learnedWordIntervals[key] = 0;
                    gameState.learnedWordIntervals[`${key}_last`] = gameState.globalQuestionCount;
                } else if (currentState === 'learned') {
                    gameState.wordStates[key] = 'weak';
                } else if (currentState === 'unlearned') {
                    gameState.wordStates[key] = 'weak';
                    gameState.wordsLearned++;
                    checkLevelUp();
                }
                // If already weak, stay weak.

                // Points Logic: Unlearned=1, Weak=2, Others=1
                let basePoints = 1;
                if (currentState === 'weak') {
                    basePoints = 2;
                } else if (currentState === 'unlearned') {
                    basePoints = 1;
                } else {
                    basePoints = 1;
                }
                const finalPoints = basePoints * gameState.vocabLevel;
                gameState.points += finalPoints;

                // showCoinPopup(finalPoints); // Maybe don't show popup for "Incorrect"? 
                // Let's keep it positive. Learning is earning.

                updateDisplay();
                animateCharacter();
                saveGame();
            } else {
                // If already flipped, clicking it again = Next Word
                showNextWord();
            }
        }

        // ... checkLevelUp ...
        // ... addNextWordSet ...

        // FIX: Remove legacy function inside loop or whatever caused issues

        function checkLevelUp() {
            const unlearnedCount = getWordsByMode('unlearned').length;
            const addWordsContainer = document.getElementById('addWordsContainer');
            if (!addWordsContainer) return;

            let maxSet = 0;
            if (vocabularyDatabase[gameState.currentLevel] && vocabularyDatabase[gameState.currentLevel].length > 0) {
                maxSet = Math.max(...vocabularyDatabase[gameState.currentLevel].map(v => v.set));
            }

            if (unlearnedCount === 0 && gameState.vocabLevel < maxSet) {
                addWordsContainer.style.display = 'block';
            } else {
                addWordsContainer.style.display = 'none';
            }
        }

        function addNextWordSet() {
            let maxSet = 0;
            if (vocabularyDatabase[gameState.currentLevel] && vocabularyDatabase[gameState.currentLevel].length > 0) {
                maxSet = Math.max(...vocabularyDatabase[gameState.currentLevel].map(v => v.set));
            }
            if (gameState.vocabLevel >= maxSet) {
                alert('„Åô„Åß„Å´ÂÖ®„Å¶„ÅÆ„Çª„ÉÉ„Éà„ÅåËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„ÅôÔºÅ');
                return;
            }

            gameState.vocabLevel++;
            loadVocabularyForLevel();
            initializeWordStates();
            showCoinPopup(`üéâ „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºÅË™ûÂΩô„É¨„Éô„É´ ${gameState.vocabLevel}`, true);
            updateDisplay();
            saveGame();
            showNextWord();
        }

        function animateCharacter() {
            // Character UI removed. No-op.
        }

        function updateDisplay() {
            const rawPoints = Math.floor(gameState.points);
            let displayPoints = rawPoints;
            if (rawPoints >= 100000) {
                // 100k notation
                displayPoints = Math.floor(rawPoints / 1000) + 'k';
            }
            document.getElementById('points').textContent = displayPoints;
            updateWordStats();
            updateWordStats();
            updateModeButtons();
            updateProgress();
        }

        // --- RPG Animation Logic ---
        // --- RPG Animation Logic ---
        let animTimer = null;

        function playAnimation(type) {
            const hero = document.getElementById('heroCharacter');
            const slime = document.getElementById('enemySlime');

            // Clear previous timers to prevent overlap
            if (animTimer) {
                clearTimeout(animTimer);
                animTimer = null;
            }

            // Default State: Idle (Row 1), Slime hidden
            // Reset to ensure clean transition
            hero.className = 'pixel-art';

            if (type === 'idle') {
                hero.classList.add('anim-idle');
                slime.style.opacity = '0';
                return;
            }

            if (type === 'attack') {
                hero.className = 'pixel-art anim-attack';
                slime.className = 'pixel-art anim-slime'; // Ensure animation runs
                slime.style.opacity = '1';

                // Duration: 0.8s * 2 loops = 1600ms
                animTimer = setTimeout(() => {
                    // Revert to Idle
                    hero.className = 'pixel-art anim-idle';
                    // Hide Slime
                    slime.style.opacity = '0';
                }, 1600);

            } else if (type === 'victory') {
                hero.className = 'pixel-art anim-cheer';
                // Slime should be hidden
                slime.style.opacity = '0';

                // Duration: 0.8s * 2 loops = 1600ms
                animTimer = setTimeout(() => {
                    hero.className = 'pixel-art anim-idle';
                }, 1600);
            }
        }

        function getCategoryLevel(category) {
            // Fix: Iterate over the actual vocabulary list for this category
            // instead of relying on key prefixes (which fail for referenced words).
            const words = vocabularyDatabase[category] || [];
            let count = 0;

            words.forEach(word => {
                // Use the shared helper to get the correct key (handles refs)
                const key = getWordKey(word, category);
                const state = gameState.wordStates[key];
                if (state === 'learned' || state === 'perfect' || state === 'weak') {
                    count++;
                }
            });

            return Math.floor(count / 20) + 1;
        }

        function updateProgress() {
            // Calculate Progress based on Valid Words in current level
            const validWords = vocabulary; // Currently loaded vocabulary array
            if (!validWords || validWords.length === 0) {
                document.querySelectorAll('.js-progress-percent').forEach(el => el.textContent = "0");
                document.querySelectorAll('.js-progress-bar-fill').forEach(el => el.style.width = "0%");
            } else {
                const total = validWords.length;
                const learnedCount = getWordsByMode('learned').length;
                const perfectCount = getWordsByMode('perfect').length;
                const learnedTotal = learnedCount + perfectCount;

                const percent = Math.floor((learnedTotal / total) * 100);

                // Update DOM - Support multiple instances (PC/Mobile)
                document.querySelectorAll('.js-progress-percent').forEach(el => el.textContent = percent);
                document.querySelectorAll('.js-progress-bar-fill').forEach(el => el.style.width = `${percent}%`);

                // Determine Title (Mage Theme) based on percentage
                let title = "Ë¶ãÁøí„ÅÑÈ≠îË°ìÂ∏´"; // 0-9
                if (percent >= 100) title = "È≠îÊ≥ï„ÅÆÁ•û";
                else if (percent >= 90) title = "Ë≥¢ËÄÖ";
                else if (percent >= 70) title = "Â§ßÈ≠îÂ∞éÂ£´";
                else if (percent >= 50) title = "ÁéãÂÆÆÈ≠îË°ìÂ∏´";
                else if (percent >= 30) title = "ÊâãÁ∑¥„Çå„ÅÆÈ≠îÂ∞éÂ£´";
                else if (percent >= 10) title = "ÈßÜ„ÅëÂá∫„Åó„ÅÆÈ≠îÊ≥ï‰Ωø„ÅÑ";

                document.querySelectorAll('.js-current-title').forEach(el => el.textContent = title);
            }

            // --- World Level Calculation ---
            // Sum of levels from Junior, Basic, Daily, Exam1
            const categories = ['junior', 'basic', 'daily', 'exam1'];
            let worldLevel = 0;
            categories.forEach(cat => {
                worldLevel += getCategoryLevel(cat);
            });

            // Update Game State
            gameState.vocabLevel = worldLevel;

            // Update World Level Display (Support multiple instances)
            document.querySelectorAll('.js-vocab-level-value').forEach(el => {
                el.textContent = worldLevel;
            });

            // --- Local Level Calculation (for current category) ---
            const localLevel = getCategoryLevel(gameState.currentLevel);
            document.querySelectorAll('.js-local-level-value').forEach(el => {
                el.textContent = localLevel;
            });

            const vocabLevelDisplay = document.getElementById('vocabLevelDisplay');
            if (vocabLevelDisplay) {
                vocabLevelDisplay.textContent = worldLevel;
            }

            // Update Label to "„ÉØ„Éº„É´„Éâ„É¨„Éô„É´"
            const labelContainer = document.querySelector('.vocab-level-display');
            if (labelContainer && labelContainer.childNodes[0].nodeType === 3) {
                labelContainer.childNodes[0].textContent = "„ÉØ„Éº„É´„Éâ„É¨„Éô„É´: ";
            }

            // --- Local Level Calculation ---
            // Level for the current category
            const currentLocalLevel = getCategoryLevel(gameState.currentLevel);

            const titleDisplay = document.querySelector('.title-display');
            if (titleDisplay) {
                let levelSpan = document.getElementById('playerLevelDisplay');
                if (!levelSpan) {
                    levelSpan = document.createElement('span');
                    levelSpan.id = 'playerLevelDisplay';
                    levelSpan.style.marginLeft = '10px';
                    levelSpan.style.color = '#667eea';
                    titleDisplay.appendChild(levelSpan);
                }
                levelSpan.textContent = `Lv.${currentLocalLevel}`;
            }
        }



        function updateWordStats() {
            // Unlearned
            document.getElementById('unlearnedCount').textContent = getWordsByMode('unlearned').length;
            // Learned
            document.getElementById('learnedCount').textContent = getWordsByMode('learned').length;
            // Perfect (New)
            document.getElementById('perfectCount').textContent = getWordsByMode('perfect').length;
            // Weak
            document.getElementById('weakCount').textContent = getWordsByMode('weak').length;
        }

        function updateModeButtons() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === gameState.currentMode) {
                    btn.classList.add('active');
                }
            });

            if (gameState.randomMode) {
                document.getElementById('randomCheckbox').classList.add('checked');
                // document.getElementById('randomNotice').style.display = 'inline'; // Removed as requested
                // Disable mode buttons visually
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.add('disabled');
                });
            } else {
                document.getElementById('randomCheckbox').classList.remove('checked');
                document.getElementById('randomNotice').style.display = 'none';
                // Enable mode buttons
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('disabled');
                });
            }

            if (gameState.autoMode) {
                document.getElementById('autoCheckbox').classList.add('checked');
            } else {
                document.getElementById('autoCheckbox').classList.remove('checked');
            }
        }

        function showCoinPopup(amount, isLevelUp = false) {
            const popup = document.createElement('div');
            popup.className = 'coin-popup';

            if (isLevelUp) {
                popup.textContent = amount;
            } else {
                popup.textContent = `+${Math.floor(amount)} gold`;
            }

            document.body.appendChild(popup);

            setTimeout(() => {
                popup.remove();
            }, 600);
        }

        // --- SIMPLE MODE LOGIC ---
        function openSimpleModeModal() {
            document.getElementById('simpleModeModal').style.display = 'flex';
        }

        function startSimpleMode(level) {
            document.getElementById('simpleModeModal').style.display = 'none';
            document.body.classList.add('simple-mode');

            if (level === 'wordbook') {
                // Open Wordbook Selection Modal
                // Assuming openWordbookModal() exists or we find the logic.
                // Re-using existing button click logic is safest if function undefined.
                const wbBtn = document.getElementById('wordbookBtn');
                if (wbBtn) wbBtn.click();
            } else {
                // Set Level
                const btn = document.querySelector(`.level-btn[data-level="${level}"]`);
                if (btn) btn.click();
            }
        }

        function exitSimpleMode() {
            document.body.classList.remove('simple-mode');
        }

        init();
        initTrialSystem(); // Start Trial Timer
    </script>
    <!-- Simple Mode Category Selection Modal -->
    <div id="simpleModeModal" class="modal-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10001; justify-content: center; align-items: center;">
        <div class="modal-content"
            style="background: white; padding: 30px; border-radius: 12px; max-width: 90%; width: 400px; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.3);">
            <h2 style="margin-top: 0; color: #333; margin-bottom: 20px;">üì± „Ç∑„É≥„Éó„É´„É¢„Éº„ÉâË®≠ÂÆö</h2>
            <p style="color: #666; margin-bottom: 20px; font-size: 14px;">Âá∫È°åÁØÑÂõ≤„ÇíÈÅ∏Êäû„Åó„Å¶„Çπ„Çø„Éº„ÉàÔºÅ</p>

            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button onclick="startSimpleMode('junior')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-weight: bold; color: #333;">üî∞
                    ‰∏≠Â≠¶„É¨„Éô„É´</button>
                <button onclick="startSimpleMode('basic')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-weight: bold; color: #333;">üìö
                    Âü∫Á§é„É¨„Éô„É´</button>
                <button onclick="startSimpleMode('daily')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-weight: bold; color: #333;">üé¨
                    Ê®ôÊ∫ñ„É¨„Éô„É´</button>
                <button onclick="startSimpleMode('exam1')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-weight: bold; color: #333;">üìñ
                    ÂèóÈ®ì„É¨„Éô„É´</button>
                <!-- Wordbook Option -->
                <button onclick="startSimpleMode('wordbook')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: linear-gradient(135deg, #6c5ce7, #a29bfe); color: white; cursor: pointer; font-weight: bold;">üìò
                    ÂçòË™ûÂ∏≥</button>
            </div>

            <button onclick="document.getElementById('simpleModeModal').style.display='none'"
                style="margin-top: 20px; background: none; border: none; color: #999; text-decoration: underline; cursor: pointer;">„Ç≠„É£„É≥„Çª„É´</button>
        </div>
    </div>

    <!-- Simple Mode Exit Button (Hidden by default) -->
    <button id="exitSimpleModeBtn" onclick="exitSimpleMode()"
        style="display: none; position: fixed; top: 15px; right: 15px; z-index: 300; background: #333; color: white; border: none; padding: 5px 12px; border-radius: 20px; font-size: 12px; cursor: pointer; opacity: 0.8;">
        ‚úï ÈÄöÂ∏∏„É¢„Éº„Éâ„Å∏Êàª„Çã
    </button>

    <!-- Help Modal -->
    <div id="helpModal" class="modal-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 10000; justify-content: center; align-items: center;">
        <div class="modal-content"
            style="background: white; padding: 25px; border-radius: 15px; max-width: 90%; width: 450px; text-align: left; box-shadow: 0 10px 30px rgba(0,0,0,0.3); position: relative;">
            <button id="closeHelpModal"
                style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: #888;">&times;</button>
            <h2
                style="margin-top: 0; border-bottom: 2px solid #ddd; padding-bottom: 10px; color: #6c5ce7; text-align: center;">
                ÈÅä„Å≥Êñπ„Ç¨„Ç§„Éâ</h2>

            <div style="font-weight: bold; margin-top: 15px; color: #333;">„ÄêÊåáÈáù„ÄëÂæóÊÑèÂçòË™û„Å®Ëã¶ÊâãÂçòË™û„Çí‰ªïÂàÜ„Åë„Å¶„Åè„Å†„Åï„ÅÑ</div>
            <ul style="margin: 10px 0 20px 0; padding-left: 20px; color: #444; line-height: 1.8; font-size: 15px;">
                <li>ÊÑèÂë≥„Åå„Çè„Åã„Çã‚Üí„ÄåÂçòË™û„Ç´„Éº„Éâ„Äç„Çí„Çø„ÉÉ„Éó</li>
                <li>„Çè„Åã„Çâ„Å™„ÅÑ‚Üí„ÄåÊÑèÂë≥„Ç´„Éº„Éâ„Äç„Çí„Çø„ÉÉ„Éó</li>
                <li>ÊÑèÂë≥„Ç´„Éº„Éâ„Çí„Çø„ÉÉ„Éó‚Üí„Åù„ÅÆÂçòË™û„ÅØ„ÄåËã¶Êâã„Çæ„Éº„É≥„Äç„Å∏</li>
                <li>„É©„É≥„ÉÄ„É†Âá∫È°å:Êú™Âá∫È°å„Çí‰∏≠ÂøÉ„Å´„ÄÅËã¶Êâã„ÇÇÊ∑∑„Åú„Å¶Âá∫È°å!Ôºà„Ç™„Çπ„Çπ„É°Ôºâ</li>
                <li>Âè≥‰∏ä„ÄÅ"ÂçòË™ûÂ∏≥Ê©üËÉΩ"„Åß„ÅäÂ•Ω„Åø„ÅÆ„Åæ„Å®„Åæ„Çä„ÅßÂá∫È°å„ÇÇÂèØËÉΩÔºÅ</li>
                <li>1Êó•10ÂàÜ„ÅÆÂà∂Èôê„ÅØ„ÄÅNoteÁâπÂÖ∏„ÅÆ„Éë„Çπ„ÉØ„Éº„Éâ„ÅßËß£Èô§ÂèØËÉΩ</li>
            </ul>
            <div style="text-align: center; margin-bottom: 20px;">
                <span style="font-size: 15px; color: #444;">Ëß£Èô§„ÅØ</span>
                <button onclick="showLockScreen(); document.getElementById('helpModal').style.display='none';"
                    style="background: none; border: none; color: #667eea; text-decoration: underline; cursor: pointer; font-size: 16px; font-weight: bold;">
                    „Ç≥„ÉÅ„É©
                </button>
                <span style="font-size: 15px; color: #444;">„Åã„Çâ</span>
            </div>

            <div style="text-align: center; margin-top: 25px;">
                <a href="https://note.com/tenioha_eng/n/n5918d72138bd?sub_rt=share_pb" target="_blank"
                    style="display: inline-block; background: #00b894; color: white; padding: 12px 25px; text-decoration: none; border-radius: 25px; font-weight: bold; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.2s;">
                    üìö Ë©≥„Åó„ÅÑ‰Ωø„ÅÑÊñπ„ÅØ„Åì„Å°„Çâ (Note)
                </a>
            </div>
        </div>
    </div>
    <div id="wordbookModal" class="modal-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div class="modal-content"
            style="background: white; padding: 20px; border-radius: 12px; max-width: 90%; width: 400px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <h2 style="margin-top: 0; color: #333;">ÂçòË™ûÂ∏≥„ÇíÈÅ∏Êäû</h2>
            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                <button class="wordbook-item-btn" data-level="selection1900"
                    style="padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-size: 16px; font-weight: bold; color: #555; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <span style="font-size: 24px;">ü¶ñ</span> Âé≥ÈÅ∏ 1900+
                </button>
                <button class="wordbook-item-btn" data-level="selection1400"
                    style="padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-size: 16px; font-weight: bold; color: #555; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <span style="font-size: 24px;">üêï</span> Âé≥ÈÅ∏ 1400+
                </button>
                <button class="wordbook-item-btn" data-level="sys_2000"
                    style="padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-size: 16px; font-weight: bold; color: #555; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <span style="font-size: 24px;">üíª</span> „Ç∑„Çπ„ÉÜ„É†WORDS (2077Ë™û)
                </button>
                <!-- Future wordbooks can be added here -->
            </div>
            <button id="closeWordbookModal"
                style="margin-top: 20px; padding: 8px 20px; border: none; background: #ddd; border-radius: 5px; cursor: pointer;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <script>
        // Modal Logic
        const wordbookBtn = document.getElementById('wordbookBtn');
        const wordbookModal = document.getElementById('wordbookModal');
        const closeWordbookModal = document.getElementById('closeWordbookModal');
        const wordbookItems = document.querySelectorAll('.wordbook-item-btn');

        if (wordbookBtn) {
            wordbookBtn.addEventListener('click', () => {
                wordbookModal.style.display = 'flex';
            });
        }

        if (closeWordbookModal) {
            closeWordbookModal.addEventListener('click', () => {
                wordbookModal.style.display = 'none';
            });
        }

        // Help Modal Logic
        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const closeHelpModal = document.getElementById('closeHelpModal');

        if (helpBtn) {
            helpBtn.addEventListener('click', () => {
                helpModal.style.display = 'flex';
            });
        }

        if (closeHelpModal) {
            closeHelpModal.addEventListener('click', () => {
                helpModal.style.display = 'none';
            });
        }

        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.style.display = 'none';
            }
        });

        wordbookModal.addEventListener('click', (e) => {
            if (e.target === wordbookModal) {
                wordbookModal.style.display = 'none';
            }
        });

        wordbookItems.forEach(btn => {
            btn.addEventListener('click', () => {
                const level = btn.dataset.level;
                switchLevel(level);
                wordbookModal.style.display = 'none';
            });
        });
    </script>
</body>

</html>