<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ëã±ÂçòË™ûÂ≠¶Áøí„ÇØ„É™„ÉÉ„Ç´„Éº</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6c5ce7">
    <link rel="icon" href="icon-512.png" type="image/png">
    <link rel="apple-touch-icon" href="icon-512.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700;900&family=Poppins:wght@400;600;700;800&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            /* Deep Space / Magic Purple */
            background: linear-gradient(135deg, #13547a 0%, #80d0c7 100%);
            /* Let's try a fresh "Mystic Teal" or keep purple? 
               User liked the purple but maybe "Magic" needs more depth. 
               Let's go nicely deep purple/blue: */
            background: linear-gradient(135deg, #6B73FF 0%, #000DFF 100%);
            /* Deep Blue */
            background: linear-gradient(135deg, #9796f0 0%, #fbc7d4 100%);
            /* Pastel? No. */
            background: linear-gradient(135deg, #3b41c5 0%, #a981bb 49%, #ffc8a9 100%);
            /* Sunset Magic - nice breadth */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.85);
            /* Semi-transparent */
            backdrop-filter: blur(12px);
            /* Frosted Glass */
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            /* Subtle edge */
            border-radius: 24px;
            /* More modern roundness */
            padding: 50px 30px 30px 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.25);
            /* Colored shadow for depth */
            max-width: 900px;
            width: 100%;
        }

        .level-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: flex-end;
        }

        .level-btn {
            background: white;
            color: #555;
            border: 1px solid rgba(0, 0, 0, 0.05);
            padding: 10px 24px;
            border-radius: 50px;
            /* Pill shape */
            cursor: pointer;
            font-size: 15px;
            font-weight: 700;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .level-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.2);
        }

        .level-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .file-upload-area {
            background: #f8f9fa;
            border: 2px dashed #667eea;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .file-upload-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .file-upload-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .file-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }

        /* Progress Bar & Title Styles */
        .progress-section {
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        .title-display {
            font-size: 16px;
            font-weight: bold;
            color: #555;
        }

        .title-value {
            color: #d32f2f;
            font-size: 18px;
            margin-left: 5px;
        }

        .progress-text {
            font-size: 14px;
            color: #777;
            font-weight: bold;
        }

        .progress-bar-bg {
            background: #e0e0e0;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            margin-top: 8px;
            position: relative;
        }

        .progress-bar-fill {
            background: linear-gradient(90deg, #4caf50, #81c784);
            height: 100%;
            width: 0%;
            transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            /* Bouncy fill */
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            /* Glowing Bar */
        }

        .header {
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .stats {
            flex: 1;
        }

        .points {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            white-space: nowrap;
            /* Force single line */
        }

        .vocab-level {
            font-size: 18px;
            color: #666;
            margin-top: 5px;
        }

        .vocab-level-display {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        .play-time {
            font-size: 14px;
            color: #999;
            margin-top: 3px;
        }

        .mode-buttons {
            display: flex;
            gap: 10px;
        }

        .mode-btn {
            background: #e0e0e0;
            color: #333;
            border: none;
            padding: 8px 15px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 90px;
        }

        .mode-count {
            font-size: 12px;
            opacity: 0.9;
            margin-top: 2px;
            font-weight: normal;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
        }

        .mode-btn.unlearned {
            background: #90caf9;
        }

        .mode-btn.learned {
            background: #4caf50;
            color: white;
        }

        .mode-btn.perfect {
            background: #ffd700;
            color: #333;
        }

        .mode-btn.weak {
            background: #f44336;
            color: white;
        }

        .stat-item.perfect {
            background: #fff9c4;
        }

        .mode-btn.active {
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }

        .mode-btn:disabled,
        .mode-btn.disabled {
            opacity: 0.8;
            /* Less transparent */
            cursor: not-allowed;
            pointer-events: none;
            filter: grayscale(30%);
            /* Subtle grayscale */
        }

        .mode-btn span {
            white-space: nowrap;
            /* Prevent text wrapping */
        }

        .random-notice {
            font-size: 11px;
            color: #999;
            margin-right: 10px;
        }

        .add-words-btn {
            background: #4caf50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .add-words-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .auto-mode-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s;
        }

        .auto-mode-container:hover {
            background: #e9ecef;
        }

        .auto-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #9c27b0;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .auto-checkbox.checked {
            background: #9c27b0;
        }

        .auto-checkbox.checked::after {
            content: '‚úì';
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .auto-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            white-space: nowrap;
            /* Prevent text wrapping */
        }

        .pos-filter-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-right: 10px;
        }

        .pos-checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s;
        }

        .pos-checkbox-item:hover {
            background: #e9ecef;
        }

        .pos-checkbox-item input[type="checkbox"] {
            cursor: pointer;
        }



        .main-content {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
        }

        .cards-section {
            flex: 1;
        }

        .cards-area {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }

        .card {
            flex: 1;
            background: white;
            /* Gradient Border/Glow effect can be done with box-shadow */
            border: none;
            border-radius: 20px;
            padding: 40px 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 240px;
            position: relative;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05), inset 0 0 0 2px #f0f0f5;
            /* Subtle border inset */
        }

        .card:hover {
            transform: translateY(-6px) scale(1.02);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.25);
            /* Border highlight on hover */
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.25), inset 0 0 0 2px #667eea;
        }

        .card:active {
            transform: translateY(-2px);
        }

        .card-label {
            position: absolute;
            top: 15px;
            font-size: 14px;
            color: #667eea;
            font-weight: bold;
        }

        .card-content {
            font-size: 36px;
            font-weight: bold;
            color: #333;
            text-align: center;
        }

        .meaning-card .card-content {
            font-size: 20px;
            line-height: 1.4;
        }

        .card-back {
            display: none;
        }

        .card.flipped .card-front {
            display: none;
        }

        .card.flipped .card-back {
            display: block;
        }

        .example-area {
            background: #fff9e6;
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speaker-btn {
            background: #667eea;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .speaker-btn:hover {
            background: #5568d3;
            transform: scale(1.1);
        }

        .undo-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 4px 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            z-index: 10;
        }

        .undo-btn:hover {
            background: #e0e0e0;
            transform: scale(1.05);
        }

        .undo-btn:disabled {
            opacity: 0.5;
            cursor: default;
            transform: none;
        }

        .example-text {
            flex: 1;
        }

        .example-label {
            font-size: 11px;
            color: #996600;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .example-sentence {
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        .character-area {
            width: 200px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .character {
            font-size: 80px;
            margin: 20px 0;
        }

        .character-title {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .character-level {
            font-size: 14px;
            color: #666;
        }

        .no-words {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 18px;
        }

        .coin-popup {
            position: fixed;
            top: 30px;
            left: 200px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.6);
            z-index: 1000;
            animation: popupSlide 0.6s ease-out;
            pointer-events: none;
        }

        @keyframes popupSlide {
            0% {
                transform: translateX(-20px);
                opacity: 0;
            }

            50% {
                transform: translateX(10px);
                opacity: 1;
            }

            100% {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .review-badge {
            position: absolute;
            top: 50px;
            right: 15px;
            background: #4caf50;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        .character.working .card.working {
            animation: bounce 0.5s ease-in-out;
        }
    </style>
    <style>
        /* ... previous styles ... */
        .character-area,
        .vocab-level,
        .play-time {
            display: none !important;
        }

        /* New generic small button style */
        .icon-btn {
            background: #f0f0f0;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
            color: #666;
        }

        .icon-btn:hover {
            background: #e0e0e0;
            transform: scale(1.1);
        }

        .header-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 200;
        }

        .file-info-small {
            font-size: 12px;
            color: #888;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* RPG Styles */
        /* New Stats Position (Top Left) */
        .stats-absolute {
            position: absolute;
            top: 15px;
            left: 20px;
            z-index: 100;
            transform: scale(0.8);
            transform-origin: top left;
        }

        /* RPG Stage (Now Inline in Header) */
        .rpg-inline {
            position: relative;
            width: 140px;
            height: 100px;
            /* Shifting position as requested */
            top: 40px;
            left: 40px;
        }

        .pixel-art {
            width: 50px;
            /* Reduced further to 50px to prevent clipping */
            height: 64px;
            background-image: url('assets/char_sprite.png?v=17');
            background-size: 300px 256px;
            /* Explicit size: 6 cols * 50px, 4 rows * 64px */
            image-rendering: pixelated;
            transform: scaleX(-1) scale(2.5);
            /* Flip horizontally to face Right, Scale 2.5 */
            transform-origin: center;
        }

        /* Frames: 0px to -300px via steps(6) */
        @keyframes sprite-play {
            from {
                background-position-x: 0px;
            }

            to {
                background-position-x: -300px;
            }
        }

        /* Rows */
        .anim-idle {
            background-position-y: 0px;
            animation: sprite-play 1.2s steps(6) infinite;
        }

        .anim-attack {
            background-position-y: -64px;
            /* 2nd Row */
            animation: sprite-play 0.8s steps(6) infinite;
            transform: scaleX(1) scale(2.5);
            /* Flip back to face opposite of Idle */
        }

        .anim-cheer {
            background-position-y: -128px;
            /* 3rd Row */
            animation: sprite-play 0.8s steps(6) infinite;
            transform: scaleX(1) scale(2.2);
            /* Flip back to face opposite of Idle */
        }

        .anim-slime {
            background-position-y: -192px;
            /* 4th Row */
            animation: sprite-play 0.8s steps(6) infinite;

            position: absolute;
            left: 80px;
            /* To the right of the hero */
            top: 20px;
            filter: hue-rotate(0deg);
        }



        .taking-damage {
            animation: flash 0.2s infinite;
        }

        @keyframes flash {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.2;
            }

            100% {
                opacity: 1;
            }
        }

        /* Filter Compact Styles */
        .pos-filter-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: nowrap;
            overflow-x: auto;
            /* Allow scroll on very small screens, but aim for single line */
            white-space: nowrap;
        }

        .filter-label {
            font-weight: bold;
            font-size: 14px;
            color: #555;
            margin-right: 5px;
        }

        .pos-checkbox-item {
            font-size: 13px;
            /* Smaller font */
            color: #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            /* Tight gap between box and text */
        }

        /* --- MOBILE RESPONSIVE STYLES --- */
        /* --- MOBILE RESPONSIVE STYLES --- */
        @media (max-width: 768px) {
            body {
                padding: 20px 0px;
                /* Vertical 20px, Horizontal 0px (Full Width) */
            }

            /* 1. Container & Layout */
            .container {
                width: 100%;
                /* Fill available space */
                max-width: 100%;
                padding: 15px 10px;
                padding-top: 90px;
                /* Reverted to 90px */
                margin: 0 auto;
            }

            /* 2. Stack Cards Vertically */
            .cards-area {
                flex-direction: column;
                /* Stack top-to-bottom */
                gap: 15px;
                align-items: stretch;
                /* Cards take full width */
            }

            .card {
                width: 100%;
                /* Full width */
                min-height: 160px;
                /* Slightly shorter default */
            }

            .card .card-content {
                font-size: 28px;
                /* Slightly smaller text for long words */
            }

            /* 3. Adjust Header */
            .header {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
                margin-top: 50px;
                /* Space for EXP/Stats at top */
            }

            /* Right Header Controls (Mode, etc) */
            .header>div:last-child {
                width: 100%;
                display: flex;
                flex-direction: column;
                /* Stack auto-toggles above modes */
                align-items: flex-start !important;
                position: relative;
                /* For absolute character positioning inside */
            }

            /* Mode Buttons: 2x2 Grid on RIGHT (40% width) */
            .mode-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr;
                /* 2 cols */
                gap: 8px;
                width: 40%;
                /* Leave 60% for character on Left */
                margin-top: 10px;
                margin-left: auto;
                /* Push to Right side */
            }

            .mode-btn {
                flex: unset;
                width: auto;
                min-width: unset;
                height: 50px;
                /* Uniform height */
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                font-size: 13px;
            }

            /* Hide counts if too cramped, or keep small */
            .mode-count {
                font-size: 11px;
            }

            /* Character: Absolute LEFT of Mode Buttons */
            .rpg-inline {
                position: absolute;
                bottom: -20px;
                /* Moved down 20px */
                right: auto;
                top: auto;
                left: 20px;
                /* Moved right 10px (10+10) */
                transform: scale(0.8);
                /* Increased by ~20% */
                transform-origin: bottom left;
                margin-bottom: 0;
                z-index: 50;
                pointer-events: none;
            }

            /* 4. EXP & Stats: Keep at Top Left */
            .stats-absolute {
                transform: scale(0.85);
                top: 10px;
                left: 10px;
                transform-origin: top left;
                z-index: 100;
                width: auto;
            }

            /* Level Selector: Move DOWN below Stats to prevent overlap */
            .level-selector {
                flex-direction: row;
                flex-wrap: nowrap;
                justify-content: flex-end;
                gap: 3px;
                /* Even tighter gap */
                padding-right: 0px;
                overflow-x: auto;
                /* Allow scroll if needed */
                padding-bottom: 5px;
                position: absolute;
                top: 70px;
                /* NEW: Reverted to 60px */
                right: 5px;
                /* Slightly more space on right */
                width: auto;
                max-width: 100%;
                /* Ensure it doesn't overflow screen width logically */
                margin: 0;
            }

            /* Compact Level Buttons for Mobile */
            .level-selector .level-btn {
                padding: 4px 8px;
                /* Extremely compact vertical/horizontal */
                font-size: 11px;
                /* Smaller text */
                white-space: nowrap;
                min-width: unset;
                /* Remove any min-width */
            }

            /* Fix Container padding to account for TALLER fixed header zone */
            .container {
                width: 95%;
                padding: 15px;
                padding-top: 90px;
                /* NEW: Adjusted to 90px (User Req: -20px further) */
                margin: 0 auto;
            }

            /* Compact Level Buttons for Mobile */
            .level-selector .level-btn {
                padding: 4px 8px;
                font-size: 11px;
                white-space: nowrap;
                min-width: unset;
            }

            /* Remove huge header margin on mobile */
            .header {
                margin-bottom: 5px;
            }

            /* Adjust Progress Bar Section */
            .progress-section {
                margin-top: 20px;
            }

            /* 5. Filter Scroll */
            .pos-filter-container {
                -webkit-overflow-scrolling: touch;
                padding-bottom: 5px;
            }

            /* 6. Fix Simple Mode Switch Position */
            .simple-switch-container {
                top: 55px !important;
                left: 10px !important;
            }
        }

        /* Trial Overlay Styles */
        .trial-overlay {
            position: fixed;
            top: 0;
            /* Added top:0 to ensure full coverage */
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: none;
            /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }

        .trial-content {
            background: #2d3436;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 400px;
        }

        .trial-title {
            font-size: 24px;
            margin-bottom: 20px;
            color: #ff7675;
            font-weight: bold;
        }

        .trial-message {
            margin-bottom: 30px;
            line-height: 1.6;
            color: #dfe6e9;
        }

        .unlock-input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 8px;
            border: 1px solid #636e72;
            background: #b2bec3;
            color: #2d3436;
            font-size: 16px;
            text-align: center;
        }

        .unlock-btn {
            background: #0984e3;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: background 0.3s;
        }

        .unlock-btn:hover {
            background: #74b9ff;
        }

        .trial-links {
            margin-top: 20px;
            font-size: 14px;
            color: #b2bec3;
        }

        .trial-links a {
            color: #74b9ff;
            text-decoration: none;
        }

        /* Trial Timer UI */
        .trial-timer {
            font-size: 14px;
            color: #ff7675;
            font-weight: bold;
            background: rgba(255, 118, 117, 0.1);
            padding: 5px 10px;
            border-radius: 12px;
            border: 1px solid #ff7675;
            display: none;
            /* Hidden by default, shown if trial is active */
            white-space: nowrap;
        }

        /* Character Level "Chocon" Display */
        .char-level-display {
            position: absolute;
            top: -20px;
            /* Float above */
            right: 0px;
            /* Centered visually above right-aligned character */
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            color: #667eea;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
            white-space: nowrap;
            pointer-events: none;
            /* Animation for cute float */
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-3px);
            }
        }


        /* --- SIMPLE MODE STYLES --- */
        body.simple-mode .header,
        body.simple-mode .level-selector,
        body.simple-mode .header-controls,
        body.simple-mode .stats-absolute,
        body.simple-mode .simple-switch-container,
        body.simple-mode #trialTimerDisplay,
        body.simple-mode .pos-filter-container,
        body.simple-mode .progress-section,
        body.simple-mode .mobile-progress-wrapper,
        body.simple-mode .mobile-layout-row,
        body.simple-mode .toggle-container,
        body.simple-mode .mobile-only,
        body.simple-mode .char-level-display,
        body.simple-mode .random-notice {
            display: none !important;
        }

        body.simple-mode .container {
            margin-top: 60px;
            /* Reset reduced padding */
            max-width: 600px;
            /* Keep it focused */
        }

        body.simple-mode #exitSimpleModeBtn {
            display: block !important;
        }

        /* Leaderboard Styles */
        .ranking-btn {
            background: linear-gradient(135deg, #f1c40f, #f39c12);
            border: 1px solid #e67e22;
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 10px;
            /* Adjusted to 10px */
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            /* Center text */
            width: 110px;
            /* Fixed width */
            box-sizing: border-box;
            gap: 5px;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .ranking-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .leaderboard-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .lb-tab {
            flex: 1;
            padding: 10px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: bold;
            color: #999;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .lb-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .ranking-list {
            max-height: 300px;
            overflow-y: auto;
            text-align: left;
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }

        .ranking-item.is-me {
            background: #eef2ff;
            border-left: 4px solid #667eea;
            font-weight: bold;
        }

        .rank-num {
            width: 30px;
            font-weight: bold;
            color: #555;
        }

        .rank-num.top3 {
            color: #e67e22;
            font-size: 16px;
        }

        .rank-name {
            flex: 1;
            color: #333;
        }

        .rank-score {
            font-weight: bold;
            color: #667eea;
        }

        body.simple-mode .cards-area {
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <!-- Trial Lock Screen -->
    <!-- TRIAL_START -->
    <div id="trialOverlay" class="trial-overlay">
        <!-- ... content ... -->
        <div class="trial-content">
            <div class="trial-title">‚è≥ Êú¨Êó•„ÅÆ„Éó„É¨„Ç§ÊôÇÈñì„ÅØÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü</div>
            <div class="trial-message">
                ÁÑ°ÊñôÁâà„ÅØ1Êó•10ÂàÜ„Åæ„Åß„Éó„É¨„Ç§ÂèØËÉΩ„Åß„Åô„ÄÇ<br>
                Á∂ö„Åç„ÅØÊòéÊó•„Åæ„ÅüÈÅä„Çì„Åß„Åè„Å†„Åï„ÅÑÔºÅ<br>
                <br>
                <strong>Âà∂Èôê„ÇíËß£Èô§„Åô„Çã„Å´„ÅØÔºü</strong><br>
                Note„É°„É≥„Éê„Éº„Ç∑„ÉÉ„Éó„ÅÆÂêàË®ÄËëâ„ÇíÂÖ•Âäõ„Åô„Çã„Åã„ÄÅ<br>
                ÂÆåÂÖ®Áâà„ÇíË≥ºÂÖ•„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
            </div>
            <input type="password" id="unlockPassword" class="unlock-input" placeholder="ÂêàË®ÄËëâ„ÇíÂÖ•Âäõ">
            <button class="unlock-btn" onclick="unlockGame()">Ëß£Èô§„Åô„Çã</button>
            <button onclick="document.getElementById('trialOverlay').style.display = 'none';"
                style="margin-top: 10px; background: transparent; border: none; color: #999; text-decoration: underline; cursor: pointer;">Èñâ„Åò„Çã</button>

            <div class="trial-links" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                <a href="https://note.com/tenioha_eng/n/n823dfa17b5c7?sub_rt=share_pw" target="_blank"
                    style="color: #74b9ff; text-decoration: none; font-weight: bold; border: 1px solid #74b9ff; padding: 10px; border-radius: 8px;">
                    „É°„É≥„Éê„Éº„Ç∑„ÉÉ„ÉóÔºà„Çµ„Éñ„Çπ„ÇØÔºâ„ÅßËß£Èô§„Ç≠„Éº„ÇíÂÖ•Êâã
                </a>
                <a href="https://note.com/tenioha_eng/n/n84f2f394b674?sub_rt=share_pw" target="_blank"
                    style="color: #fab1a0; text-decoration: none; font-weight: bold; border: 1px solid #fab1a0; padding: 10px; border-radius: 8px;">
                    ÂÆåÂÖ®ÁâàÔºàË≤∑„ÅÑÂàá„ÇäÔºâ„ÇíË≥ºÂÖ•„Åô„Çã
                </a>
            </div>
        </div>
    </div>
    <!-- TRIAL_END -->

    <div class="container" style="position: relative;">
        <!-- Stats (Moved from Header) -->
        <!-- Stats (Moved from Header) -->
        <!-- Simple Mode Switch (Top Left) -->
        <div class="simple-switch-container"
            style="position: absolute; top: 15px; left: 15px; z-index: 200; display: flex; flex-direction: column; gap: 5px; align-items: flex-start;">
            <button class="simple-mode-btn" id="simpleModeBtn" onclick="openSimpleModeModal()"
                style="background: #fff; border: 1px solid #ddd; padding: 4px 8px; border-radius: 20px; font-size: 10px; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center; width: 110px; box-sizing: border-box; gap: 5px; color: #555; font-weight: bold;">
                üì± „Ç∑„É≥„Éó„É´Ë°®Á§∫
            </button>
            <button class="ranking-btn" id="rankingBtn" onclick="openLeaderboard()">
                üëë „É©„É≥„Ç≠„É≥„Ç∞
            </button>
        </div>

        <!-- Top Right Controls (Upload) -->
        <div class="header-controls" style="display: flex; align-items: center; gap: 10px;">
            <div id="trialTimerDisplay" class="trial-timer">ÊÆã„Çä 10:00</div>

            <!-- Profile Icon (New) -->
            <div id="headerProfileIcon" onclick="toggleProfileModal()"
                style="width: 40px; height: 40px; border-radius: 50%; background: #eee; cursor: pointer; overflow: hidden; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center;">
                <span id="headerProfileInitials" style="font-weight: bold; color: #888; font-size: 14px;">üë§</span>
                <img id="headerProfileImage" src=""
                    style="width: 100%; height: 100%; object-fit: cover; display: none;">
            </div>

            <button class="icon-btn" id="helpBtn" title="ÈÅä„Å≥Êñπ">‚ùì</button>
        </div>


        <div class="level-selector" id="levelContainer">
            <button class="level-btn" data-level="junior">üî∞ ‰∏≠Â≠¶</button>
            <button class="level-btn active" data-level="basic">üìö Âü∫Á§é</button>
            <button class="level-btn" data-level="daily">üé¨ Ê®ôÊ∫ñ</button>
            <button class="level-btn" data-level="exam1">üìñ ÂèóÈ®ì</button>
            <button class="level-btn" id="wordbookBtn" style="background: linear-gradient(135deg, #6c5ce7, #a29bfe);">
                <span class="pc-text">üìò ÂçòË™ûÂ∏≥</span>
                <span class="mobile-text">ÂçòË™ûÂ∏≥</span>
            </button>
        </div>

        <!-- PC Progress Bar (Original) - Hidden on Mobile -->
        <div class="progress-section pc-only">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <div class="title-display">Áß∞Âè∑: <span id="currentTitle" class="js-current-title title-value">Ë¶ãÁøí„ÅÑ</span>
                </div>
                <div class="progress-text"><span id="progressPercent" class="js-progress-percent">0</span>% ÈÅîÊàê</div>
            </div>
            <div class="progress-bar-bg">
                <div class="progress-bar-fill js-progress-bar-fill" id="progressBar" style="width: 0%;"></div>
            </div>
        </div>

        <div class="header">
            <div class="rpg-inline">
                <div id="enemySlime" class="pixel-art anim-slime" style="opacity: 0;"></div>

                <!-- Gold Display (Above Level) -->
                <div class="char-level-display" style="top: -42px; color: #f1c40f;">
                    üí∞ <span id="points">0</span>
                </div>

                <div class="char-level-display">Lv.<span class="js-vocab-level-value">1</span></div>
                <div id="heroCharacter" class="pixel-art anim-idle"></div>
            </div>
            <div class="header-controls-wrapper">

                <!-- Wrapper for Mobile Layout: Toggles (Left) + Progress (Right) -->
                <div class="mobile-layout-row">
                    <div class="toggle-container" style="display: flex; gap: 15px;">
                        <div class="auto-mode-container" id="autoModeToggle">
                            <div class="auto-checkbox" id="autoCheckbox"></div>
                            <div class="auto-label">
                                <span class="pc-text">ü§ñ „Ç™„Éº„Éà„É¢„Éº„Éâ</span>
                                <span class="mobile-text">„Ç™„Éº„Éà</span>
                            </div>
                        </div>
                        <div class="auto-mode-container" id="randomToggle">
                            <div class="auto-checkbox checked" id="randomCheckbox"></div>
                            <div class="auto-label">
                                <span class="pc-text">üîÄ „É©„É≥„ÉÄ„É†Âá∫È°å</span>
                                <span class="mobile-text">„É©„É≥„ÉÄ„É†</span>
                            </div>
                        </div>
                    </div>

                    <!-- Mobile Progress Bar (New) - Visible only on Mobile -->
                    <div class="mobile-progress-wrapper mobile-only" style="display: none;">
                        <!-- Level Display -->
                        <div class="level-display" style="font-weight: bold; color: #666; margin-bottom: 2px;">
                            Lv. <span class="js-local-level-value">1</span>
                        </div>

                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                            <div class="title-display">Áß∞Âè∑: <span class="js-current-title title-value">Ë¶ãÁøí„ÅÑ</span></div>
                            <div class="progress-text"><span class="js-progress-percent">0</span>% ÈÅîÊàê</div>
                        </div>
                        <div class="progress-bar-bg" style="margin-top: 2px;">
                            <div class="progress-bar-fill js-progress-bar-fill" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>

                <div
                    style="display: flex; align-items: center; gap: 10px; width: 100%; justify-content: flex-end; padding-right: 5px;">
                    <span class="random-notice" id="randomNotice" style="display: none;">„É©„É≥„ÉÄ„É†Âá∫È°å‰∏≠„ÄÇÂá∫È°åÁØÑÂõ≤„ÇíÈÅ∏Êäû„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</span>
                    <div class="mode-buttons">
                        <button class="mode-btn unlearned active" data-mode="unlearned" id="unlearnedBtn">
                            <span>üìù Êú™Â≠¶Áøí</span>
                            <span class="mode-count" id="unlearnedCount">0</span>
                        </button>
                        <button class="mode-btn learned" data-mode="learned" id="learnedBtn">
                            <span>‚úÖ ÂæóÊÑè</span>
                            <span class="mode-count" id="learnedCount">0</span>
                        </button>
                        <button class="mode-btn perfect" data-mode="perfect" id="perfectBtn">
                            <span>üèÜ ÂÆåÁíß</span>
                            <span class="mode-count" id="perfectCount">0</span>
                        </button>
                        <button class="mode-btn weak" data-mode="weak" id="weakBtn">
                            <span>üìö Ëã¶Êâã</span>
                            <span class="mode-count" id="weakCount">0</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <style>
            .mobile-text {
                display: none;
            }

            .pc-text {
                display: inline;
            }

            .pc-only {
                display: block;
            }

            .mobile-only {
                display: none;
            }

            .mobile-progress-wrapper .level-display {
                display: none !important;
            }

            /* PC Specific Tweaks */
            @media (min-width: 769px) {
                .header-controls {
                    position: absolute;
                    top: 0px;
                    /* Adjusted down by 10px (was -10px) */
                    right: 20px;
                    /* Force Right Align */
                }
            }

            @media (max-width: 768px) {
                .mobile-text {
                    display: inline;
                }

                .pc-text {
                    display: none;
                }

                .pc-only {
                    display: none !important;
                }

                .mobile-only {
                    display: flex !important;
                }

                /* Stack toggles vertically on mobile */
                .toggle-container {
                    flex-direction: column;
                    gap: 5px !important;
                    align-items: flex-start;
                    /* Left-align start */
                }

                /* Force equal width for toggles on mobile to align right edges too */
                .toggle-container .auto-mode-container {
                    min-width: 85px;
                    justify-content: flex-start;
                }

                /* Squeeze "Random" text to fit same width as "Auto" */
                #randomToggle .mobile-text {
                    font-size: 11px;
                    /* Smaller font for Random */
                    letter-spacing: -1px;
                    /* Tighter letter spacing */
                }

                /* Mobile Layout Row: Toggles + Progress Bar */
                .header-controls-wrapper {
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    align-items: flex-end;
                    width: 100%;
                    max-width: 400px;
                    /* Default for PC */
                }

                @media (max-width: 768px) {
                    .header-controls-wrapper {
                        max-width: 100%;
                        /* Allow full width on mobile */
                    }
                }

                .mobile-layout-row {
                    display: flex;
                    gap: 10px;
                    /* Reduced gap */
                    align-items: stretch;
                    /* Stretch to match heights */
                    width: 100%;
                }

                /* Mobile Toggle Container (Auto/Random) */
                .toggle-container {
                    display: flex;
                    flex-direction: column;
                    gap: 5px;
                    justify-content: space-between;
                    /* Distribute vertically */
                }

                /* Compact Auto/Random Buttons for Mobile */
                .toggle-container .auto-mode-container {
                    padding: 2px 6px;
                    margin: 0;
                    height: 48%;
                    /* Aim for half height of progress bar container */
                    box-sizing: border-box;
                    display: flex;
                    align-items: center;
                }

                .toggle-container .auto-checkbox {
                    width: 16px;
                    height: 16px;
                }

                .toggle-container .auto-label .mobile-text {
                    font-size: 10px;
                }

                /* Specific tweak for Random text size if needed */
                #randomToggle .mobile-text {
                    font-size: 10px;
                    letter-spacing: 0;
                }

                /* Fix Simple/Ranking Buttons for Mobile (Top Align) */
                .simple-switch-container {
                    top: 5px !important;
                    /* Close the gap */
                    left: 10px !important;
                }

                /* Mobile Progress Bar Styling */
                .mobile-progress-wrapper {
                    flex-grow: 1;
                    /* VARIABLE WIDTH - Fills remaining space */
                    display: flex;
                    flex-direction: column;
                    justify-content: center;

                    /* PC Style White Frame */
                    background: white;
                    padding: 3px 12px;
                    /* Compact padding */
                    border-radius: 10px;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);

                    /* No Transform Scaling - Use natural sizing */
                    width: auto;
                    min-width: 0;
                    /* Allow shrinking */
                }

                /* Compact text sizes for mobile progress elements */
                .mobile-progress-wrapper .title-display,
                .mobile-progress-wrapper .progress-text,
                .mobile-progress-wrapper .level-display {
                    font-size: 10px !important;
                }

                .mobile-progress-wrapper .title-value {
                    font-size: 11px !important;
                }

                .mobile-progress-wrapper .progress-bar-bg {
                    height: 8px !important;
                    /* Thinner bar */
                    border-radius: 4px !important;
                }
            }
        </style>

        <div class="pos-filter-container">
            <div class="filter-label">„Éï„Ç£„É´„Çø:</div>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Âêç" checked> ÂêçË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Âãï" checked> ÂãïË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="ÂΩ¢" checked> ÂΩ¢ÂÆπË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="ÂâØ" checked> ÂâØË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Âä©" checked> Âä©ÂãïË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Ââç" checked> ÂâçÁΩÆË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="Êé•" checked> Êé•Á∂öË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="‰ª£" checked> ‰ª£ÂêçË©û
            </label>
            <label class="pos-checkbox-item">
                <input type="checkbox" class="pos-filter" data-pos="other" checked> „Åù„ÅÆ‰ªñ
            </label>
        </div>

        <div id="addWordsContainer" style="text-align: center; display: none; margin-bottom: 20px;">
            <button class="add-words-btn" id="addWordsBtn">‚ûï Ê¨°„ÅÆ„Çª„ÉÉ„Éà„ÇíËøΩÂä†Ôºà„É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºâ</button>
        </div>

        <div class="main-content">
            <div class="cards-section">
                <div class="cards-area" id="cardsArea">
                    <div class="card vocab-card" id="vocabCard">
                        <div class="card-label">Ëã±ÂçòË™û„Ç´„Éº„Éâ</div>
                        <div class="card-content" id="vocabWord">„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ</div>
                    </div>

                    <div class="card meaning-card" id="meaningCard">
                        <div class="card-label">ÊÑèÂë≥„Ç´„Éº„Éâ</div>
                        <div class="card-front">
                            <div class="card-content">‚ùì</div>
                        </div>
                        <div class="card-back">
                            <div class="card-content" id="meaningText">ÊÑèÂë≥</div>
                        </div>
                    </div>
                </div>

                <div class="example-area" id="exampleArea">
                    <button class="speaker-btn" id="speakerBtn">üîä</button>
                    <div class="example-text">
                        <div class="example-label">‰æãÊñá</div>
                        <div class="example-sentence" id="exampleSentence">„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ</div>
                    </div>
                    <button class="undo-btn" id="undoBtn" onclick="undoLastAction()" disabled>‚Ü©Ô∏è Êàª„Çã</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Import External Vocabulary Data -->
    <!-- Import External Vocabulary Data -->
    <script src="data/vocabulary.js?v=2"></script>


    <script>
        let gameState = {
            points: 0,
            currentMode: 'unlearned',
            currentLevel: 'basic',
            currentWordIndex: 0,
            currentWord: null,
            wordStates: {},
            weakWordProgress: {},
            learnedWordIntervals: {},
            globalQuestionCount: 0,
            sessionStartTime: Date.now(),
            meaningCardFlipped: false,
            isReviewWord: false,
            questionCount: 0,
            autoMode: false,
            randomMode: true,
            posFilters: ['Âêç', 'Âãï', 'ÂΩ¢', 'ÂâØ', 'Âä©', 'Ââç', 'Êé•', '‰ª£', 'other'], // Active POS filters
            vocabLevel: 1,
            wordsLearned: 0 // Total words moved from unlearned
        };

        // Initialize with default or empty
        let vocabularyDatabase = (typeof DEFAULT_VOCABULARY !== 'undefined') ? JSON.parse(JSON.stringify(DEFAULT_VOCABULARY)) : {
            basic: [],
            daily: [],
            exam1: [],
            exam2: [],
            junior: []
        };

        // Merge Junior data if loaded via temp variable


        let vocabulary = [];
        let autoTimer = null;
        let gameStateHistory = []; // Stack to store previous states

        // Save current state to history (Max 1 step for now)
        function saveState() {
            // Deep copy gameState
            const stateSnapshot = JSON.parse(JSON.stringify(gameState));
            gameStateHistory.push(stateSnapshot);
            // Limit history to 1 step as per requirement (can be increased)
            if (gameStateHistory.length > 5) {
                gameStateHistory.shift();
            }
            updateUndoButton();
        }

        // Restore last state
        function undoLastAction() {
            if (gameStateHistory.length === 0) return;

            const previousState = gameStateHistory.pop();
            gameState = previousState;

            // Restore UI
            showWord(gameState.currentWord);
            updateDisplay();
            updateUndoButton();

            // Re-apply current mode button styles if needed
            updateModeButtons();
        }

        function updateUndoButton() {
            const btn = document.getElementById('undoBtn');
            if (btn) {
                btn.disabled = gameStateHistory.length === 0;
            }
        }

        // --- Trial System Config ---
        const TRIAL_CONFIG = {
            LIMIT_SECONDS: 600, // 10 minutes
            PASSWORD: "appleisbanana",
            STORAGE_KEY: "vocabGame_trialState_v2" // Changed key to force reset/migration if needed, or just keep same
        };

        let trialState = {
            unlocked: false,
            lastPlayDate: null,
            playTimeSeconds: 0
        };

        let lastTickTime = Date.now();

        // Initialize Trial
        function initTrialSystem() {
            const savedTrial = localStorage.getItem(TRIAL_CONFIG.STORAGE_KEY);

            // Get Current Date in JST (Japan Standard Time)
            const jstFormatter = new Intl.DateTimeFormat('en-CA', {
                timeZone: 'Asia/Tokyo',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
            const today = jstFormatter.format(new Date());

            if (savedTrial) {
                try {
                    const parsed = JSON.parse(savedTrial);
                    trialState = { ...trialState, ...parsed };
                } catch (e) {
                    console.error("Trial save corrupted", e);
                }
            }

            // Daily Reset (JST Midnight)
            if (trialState.lastPlayDate !== today) {
                trialState.lastPlayDate = today;
                if (!trialState.unlocked) {
                    trialState.playTimeSeconds = 0; // Reset time if not unlocked
                }
                saveTrialState();
            }

            // Initialize Tick Time
            lastTickTime = Date.now();

            // Toggle UI based on state
            updateTrialUI();

            // Check if already over limit
            checkTrialLimit();

            // Start Timer Loop
            setInterval(updateTrialTimer, 1000);
        }

        function saveTrialState() {
            localStorage.setItem(TRIAL_CONFIG.STORAGE_KEY, JSON.stringify(trialState));
        }

        function updateTrialTimer() {
            if (trialState.unlocked) {
                updateTrialUI(); // Ensure UI is hidden
                return;
            }

            const now = Date.now();
            const deltaSeconds = (now - lastTickTime) / 1000;
            lastTickTime = now;

            // Only count logical time flow. 
            // If delta is huge (e.g. computer slept for 10 days), it will add that time.
            // This effectively solves "background tab throttling" because next tick will just add the large difference.

            if (deltaSeconds > 0) {
                trialState.playTimeSeconds += deltaSeconds;
            }

            // Save every ~5 seconds (or if huge jump)
            if (Math.floor(trialState.playTimeSeconds) % 5 === 0 || deltaSeconds > 5) {
                saveTrialState();
            }

            updateTrialUI();
            checkTrialLimit();
        }

        function updateTrialUI() {
            const timerDisplay = document.getElementById('trialTimerDisplay');
            if (!timerDisplay) return;

            if (trialState.unlocked) {
                timerDisplay.style.display = 'none';
                return;
            }

            timerDisplay.style.display = 'block';

            const remaining = Math.max(0, TRIAL_CONFIG.LIMIT_SECONDS - Math.floor(trialState.playTimeSeconds));
            const m = Math.floor(remaining / 60);
            const s = Math.floor(remaining % 60);

            // Format mm:ss
            timerDisplay.textContent = `ÊÆã„Çä ${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;

            // Warning color if low
            if (remaining < 60) {
                timerDisplay.style.color = '#d63031';
                timerDisplay.style.borderColor = '#d63031';
                timerDisplay.style.backgroundColor = 'rgba(214, 48, 49, 0.1)';
            }
        }

        function checkTrialLimit() {
            if (trialState.unlocked) return;

            if (trialState.playTimeSeconds >= TRIAL_CONFIG.LIMIT_SECONDS) {
                showLockScreen();
            }
        }

        function showLockScreen() {
            const overlay = document.getElementById('trialOverlay');
            if (overlay.style.display !== 'flex') {
                overlay.style.display = 'flex';
                // Stop any game audio or timers here if needed
                clearAutoTimer();
            }
        }

        // Old unlockGame removed. Now using bridge function at bottom.

        function init() {
            loadGame();

            // Ensure compatibility with old saves if level names changed
            if (!vocabularyDatabase[gameState.currentLevel]) {
                gameState.currentLevel = 'basic';
            }

            document.addEventListener('click', () => {
                // Initialize audio context on first interaction
                if (!audioWakeLockSet) {
                    enableAudioStayAwake();
                }
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }, { once: true }); // Only needs to run once

            setupEventListeners();
            setupPOSFilters(); // Need to call this to attach listeners to new checkboxes

            // MUST load vocabulary before updateDisplay
            if (vocabulary.length === 0 && vocabularyDatabase[gameState.currentLevel].length > 0) {
                loadVocabularyForLevel();
                // If states are empty, init them
                if (Object.keys(gameState.wordStates).filter(k => k.startsWith(gameState.currentLevel)).length === 0) {
                    initializeWordStates();
                }
            }

            updateDisplay();
            showNextWord();
        }

        function setupEventListeners() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', handleFileUpload);
            }

            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const level = btn.dataset.level;
                    switchLevel(level);
                });
            });

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (btn.disabled) return;
                    const mode = btn.dataset.mode;
                    gameState.currentMode = mode;
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    showNextWord();
                    saveGame();
                });
            });

            document.getElementById('autoModeToggle').addEventListener('click', () => {
                gameState.autoMode = !gameState.autoMode;
                const checkbox = document.getElementById('autoCheckbox');
                if (gameState.autoMode) {
                    checkbox.classList.add('checked');
                    startAutoTimer();
                } else {
                    checkbox.classList.remove('checked');
                    clearAutoTimer();
                }
            });

            document.getElementById('randomToggle').addEventListener('click', () => {
                gameState.randomMode = !gameState.randomMode;
                const checkbox = document.getElementById('randomCheckbox');
                if (gameState.randomMode) {
                    checkbox.classList.add('checked');
                } else {
                    checkbox.classList.remove('checked');
                }
                updateModeButtons();
                showNextWord();
                saveGame();
            });

            // POS Filter checkboxes
            setupPOSFilters();
            document.getElementById('speakerBtn').addEventListener('click', () => {
                if (gameState.currentWord) {
                    speakWord(gameState.currentWord.word);
                }
            });

            document.getElementById('addWordsBtn').addEventListener('click', addNextWordSet);

            setupCardListeners();
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                parseCSV(text);
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            const lines = text.split('\n');
            const level = gameState.currentLevel;
            vocabularyDatabase[level] = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // CSV format: word, meaning, pos, example, set
                // If 6 columns, assume 6th is phrase, otherwise fallback
                const parts = line.split(',');
                if (parts.length >= 5) {
                    const wordObj = {
                        word: parts[0].trim(),
                        meaning: parts[1].trim(),
                        pos: parts[2].trim(),
                        example: parts[3].trim(),
                        set: parseInt(parts[4].trim())
                    };

                    if (parts.length >= 6) {
                        wordObj.phrase = parts[5].trim();
                    } else {
                        // Fallback logic if phrase is missing
                        wordObj.phrase = wordObj.meaning;
                    }

                    vocabularyDatabase[level].push(wordObj);
                }
            }

            loadVocabularyForLevel();
            initializeWordStates();
            document.getElementById('fileInfo').textContent = `‚úÖ ${vocabularyDatabase[level].length}Ë™û„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü`;
            showNextWord();
            saveGame();
        }

        function switchLevel(level) {
            gameState.currentLevel = level;
            document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));

            const targetBtn = document.querySelector(`.level-btn[data-level="${level}"]`);
            if (targetBtn) {
                targetBtn.classList.add('active');
            } else if (level.startsWith('selection')) {
                // Highlight Wordbook button if we are in a special wordbook mode
                const wbBtn = document.getElementById('wordbookBtn');
                if (wbBtn) wbBtn.classList.add('active');
            }

            loadVocabularyForLevel();
            initializeWordStates();
            updateDisplay();
            showNextWord();
            saveGame();
        }

        function loadVocabularyForLevel() {
            if (gameState.currentLevel.startsWith('selection')) {
                const rawWords = vocabularyDatabase[gameState.currentLevel] || [];
                vocabulary = rawWords.map(v => {
                    if (v.ref && v.ref !== gameState.currentLevel) {
                        let refCategory = v.ref;
                        let refWordText = v.word;

                        if (v.ref.includes(':')) {
                            const parts = v.ref.split(':');
                            refCategory = parts[0];
                            refWordText = parts[1];
                        }

                        const refArray = vocabularyDatabase[refCategory];
                        if (refArray) {
                            // Find match by word text
                            const refWord = refArray.find(r => r.word === refWordText);
                            if (refWord) {
                                // Merge referenced data (meanings, examples) but keep selection-specific metadata (set, id)
                                return {
                                    ...v,
                                    meaning: refWord.meaning,
                                    phrase: refWord.phrase,
                                    example: refWord.example,
                                    pos: refWord.pos
                                };
                            }
                        }
                    }
                    return v;
                }).filter(v => {
                    // Always include if set is not a number (e.g. "system") or matches current level logic
                    if (typeof v.set !== 'number') return true;
                    return v.set <= gameState.vocabLevel;
                });
            } else {
                vocabulary = vocabularyDatabase[gameState.currentLevel].filter(v => {
                    if (typeof v.set !== 'number') return true;
                    return v.set <= gameState.vocabLevel;
                });
            }
        }

        function getWordKey(word, level) {
            // Generalize shared progress for any word with a reference
            if (word.ref && word.ref !== level) {
                let refCategory = word.ref;
                let refWordText = word.word;

                if (word.ref.includes(':')) {
                    const parts = word.ref.split(':');
                    refCategory = parts[0];
                    refWordText = parts[1];
                }

                return `${refCategory}_${refWordText}`;
            }
            return `${level}_${word.word}`;
        }

        function initializeWordStates() {
            vocabulary.forEach(v => {
                const key = getWordKey(v, gameState.currentLevel);
                if (!gameState.wordStates[key]) {
                    gameState.wordStates[key] = 'unlearned';
                }
            });
        }

        function saveGame() {
            const data = {
                points: gameState.points,
                wordStates: gameState.wordStates,
                weakWordProgress: gameState.weakWordProgress,
                learnedWordIntervals: gameState.learnedWordIntervals,
                globalQuestionCount: gameState.globalQuestionCount,
                currentLevel: gameState.currentLevel,
                currentMode: gameState.currentMode,
                vocabLevel: gameState.vocabLevel,
                questionCount: gameState.questionCount,
                lastSaveTime: Date.now() // Track local save time for Sync Logic
            };
            localStorage.setItem('vocabClickerSave', JSON.stringify(data));

            // Leaderboard Sync (Reference defined at bottom)
            if (typeof attemptScoreSync === 'function') {
                attemptScoreSync();
            }
        }

        function loadGame() {
            const saved = localStorage.getItem('vocabClickerSave');
            if (saved) {
                const data = JSON.parse(saved);
                gameState = { ...gameState, ...data };
            }
        }

        function startPlayTimeCounter() {
            gameState.sessionStartTime = Date.now();
            playTimeInterval = setInterval(updatePlayTime, 1000);
        }

        function updatePlayTime() {
            const elapsed = Date.now() - gameState.sessionStartTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('playTime').textContent =
                `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function setupPOSFilters() {
            const checkboxes = document.querySelectorAll('.pos-filter');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    updatePOSFilters();
                    showNextWord();
                    saveGame();
                });
            });
        }

        function updatePOSFilters() {
            const checkboxes = document.querySelectorAll('.pos-filter');
            gameState.posFilters = [];
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    gameState.posFilters.push(checkbox.dataset.pos);
                }
            });
        }

        function filterWordsByPOS(words) {
            if (gameState.posFilters.length === 0) return [];
            return words.filter(word => {
                const pos = word.pos || 'other';
                return gameState.posFilters.includes(pos) ||
                    (pos !== 'Âêç' && pos !== 'Âãï' && pos !== 'ÂΩ¢' && pos !== 'ÂâØ' &&
                        pos !== 'Âä©' && pos !== 'Ââç' && pos !== 'Êé•' && pos !== '‰ª£' && gameState.posFilters.includes('other'));
            });
        }

        function checkVocabLevelUp() {
            // Re-calculate World Level
            const categories = ['junior', 'basic', 'daily', 'exam1'];
            let newWorldLevel = 0;
            categories.forEach(cat => {
                newWorldLevel += getCategoryLevel(cat);
            });

            if (newWorldLevel > gameState.vocabLevel) {
                gameState.vocabLevel = newWorldLevel;
                showCoinPopup(`üéâ „ÉØ„Éº„É´„Éâ„É¨„Éô„É´ ${gameState.vocabLevel} „Å´„Ç¢„ÉÉ„ÉóÔºÅ`, true);
            }
            updateVocabLevelDisplay();
        }

        function updateVocabLevelDisplay() {
            document.querySelectorAll('.js-vocab-level-value').forEach(el => {
                el.textContent = gameState.vocabLevel;
            });
        }

        function getWordsByMode(mode) {
            const modeWords = vocabulary.filter(v => {
                const key = getWordKey(v, gameState.currentLevel);
                return gameState.wordStates[key] === mode;
            });
            return filterWordsByPOS(modeWords);
        }

        function getEligibleLearnedWords() {
            const learnedWords = getWordsByMode('learned');
            const eligibleWords = [];

            for (const word of learnedWords) {
                const key = getWordKey(word, gameState.currentLevel);
                const interval = gameState.learnedWordIntervals[key] || 0;
                const requiredInterval = Math.pow(2, interval) * 12;
                const lastShown = gameState.learnedWordIntervals[`${key}_last`] || 0;

                if (gameState.globalQuestionCount - lastShown >= requiredInterval) {
                    eligibleWords.push(word);
                }
            }

            if (eligibleWords.length === 0 && learnedWords.length > 0) {
                return learnedWords;
            }

            return eligibleWords;
        }

        // Web Audio API Context for keeping hardware awake
        let audioContext = null;
        let audioWakeLockSet = false;

        function enableAudioStayAwake() {
            if (audioWakeLockSet) return;

            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;

                audioContext = new AudioContext();

                // Create a silent oscillator to keep the audio engine active
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.frequency.value = 440; // Frequency doesn't matter much as volume is near zero

                // Extremely low volume (but not zero) to cheat the OS silence detection
                gainNode.gain.value = 0.00001;

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(0);
                audioWakeLockSet = true;
                console.log("Audio Wake Lock engaged.");
            } catch (e) {
                console.error("Audio Wake Lock failed:", e);
            }
        }

        function speakWord(word) {
            // Ensure audio engine is awake
            if (!audioWakeLockSet) {
                enableAudioStayAwake();
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // Cancel previous speech
            speechSynthesis.cancel();

            // Small delay to allow cancellation to clear
            setTimeout(() => {
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = 'en-US';

                // Try to select a better voice
                const voices = speechSynthesis.getVoices();
                // Priority list: Google US English, Samantha (iOS/Mac), Microsoft Zira (Win)
                const preferredVoice = voices.find(v => v.name === 'Google US English') ||
                    voices.find(v => v.name === 'Samantha') ||
                    voices.find(v => v.name.includes('Google') && v.lang.startsWith('en')) ||
                    voices.find(v => v.lang === 'en-US');

                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }

                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;

                speechSynthesis.speak(utterance);
            }, 50);
        }

        function showNextWord() {
            gameState.meaningCardFlipped = false;
            clearAutoTimer();

            let words;
            let shouldShowReview = false;
            let reviewType = null;

            if (!gameState.randomMode) {
                words = getWordsByMode(gameState.currentMode);
                gameState.isReviewWord = false;
            } else {
                // NEW: Adaptive Weighted Probability Logic
                const unlearnedWords = getWordsByMode('unlearned');
                const learnedWords = getEligibleLearnedWords();
                const weakWords = getWordsByMode('weak');

                // Weights defaults: Unlearned(75), Learned(10), Weak(15)
                let weightUnlearned = 75;
                let weightLearned = 10;
                let weightWeak = 15;

                const weakCount = weakWords.length;

                // Dynamic Adjustment based on Weak Count
                if (weakCount >= 150) {
                    // Critical: Block new words almost entirely
                    weightUnlearned = 5;
                    weightLearned = 5;
                    weightWeak = 90;
                } else if (weakCount >= 100) {
                    // Warning: High priority on cleanup
                    weightUnlearned = 20;
                    weightLearned = 10;
                    weightWeak = 70;
                } else if (weakCount >= 50) {
                    // Caution: Shift balance
                    weightUnlearned = 50;
                    weightLearned = 10;
                    weightWeak = 40;
                }

                // If a category is empty, set its weight to 0 to avoid selecting it

                if (unlearnedWords.length === 0) weightUnlearned = 0;
                if (learnedWords.length === 0) weightLearned = 0;
                if (weakWords.length === 0) weightWeak = 0;

                const totalWeight = weightUnlearned + weightLearned + weightWeak;

                if (totalWeight === 0) {
                    // Fallback if absolutely nothing is available
                    words = [];
                } else {
                    const r = Math.random() * totalWeight;

                    if (r < weightUnlearned) {
                        words = unlearnedWords;
                        gameState.isReviewWord = false;
                    } else if (r < weightUnlearned + weightLearned) {
                        words = learnedWords;
                        shouldShowReview = true;
                        reviewType = 'learned';
                    } else {
                        words = weakWords;
                        shouldShowReview = true;
                        reviewType = 'weak';
                    }
                }
            }

            gameState.isReviewWord = shouldShowReview;
            gameState.globalQuestionCount++;

            if (words.length === 0) {
                showNoWordsMessage();
                return;
            }

            hideNoWordsMessage();
            gameState.currentWordIndex = Math.floor(Math.random() * words.length);
            const word = words[gameState.currentWordIndex];
            gameState.currentWord = word;

            // MAP POS to Full Name
            const posMap = {
                "Âêç": "ÂêçË©û",
                "Âãï": "ÂãïË©û",
                "ÂΩ¢": "ÂΩ¢ÂÆπË©û",
                "ÂâØ": "ÂâØË©û",
                "Âä©": "Âä©ÂãïË©û",
                "Êé•": "Êé•Á∂öË©û",
                "Ââç": "ÂâçÁΩÆË©û",
                "‰ª£": "‰ª£ÂêçË©û"
            };
            const fullPos = posMap[word.pos] || word.pos;

            // UPDATE: Display POS above Word (Full Name)
            // Visual Adjustment: shift up slightly so the WORD looks centered, not the whole block
            document.getElementById('vocabWord').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; transform: translateY(-10%);">
                    <div style="font-size: 18px; color: #667eea; font-weight: normal; margin-bottom: 5px;">${fullPos}</div>
                    <div style="font-size: 42px; font-weight: bold; line-height: 1.2;">${word.word}</div>
                </div>
            `;

            // UPDATE: Display Meaning (Large) + Minimal Phrase (Small below)

            // Label Idea: Use English "Phrase" in small caps for a cleaner look
            const phraseLabel = `<span style="font-size: 11px; color: #999; text-transform: uppercase; letter-spacing: 1.5px; display: block; margin-bottom: 4px;">PHRASE</span>`;

            // Layout: Meaning (Center/Large) -> Phrase (Below/Small)
            document.getElementById('meaningText').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;">
                    <div style="font-size: 32px; font-weight: bold; color: #333; margin-bottom: 20px;">${word.meaning}</div>
                    ${word.phrase ? `
                        <div style="text-align: center; background: #f8f9fa; padding: 10px 20px; border-radius: 12px; border: 1px solid #eef0f5;">
                            ${phraseLabel}
                            <div style="font-size: 18px; color: #444; font-weight: 500;">${word.phrase}</div>
                        </div>
                    ` : ''}
                </div>
            `;

            document.getElementById('exampleSentence').textContent = word.example;
            document.getElementById('meaningCard').classList.remove('flipped');

            const vocabCard = document.getElementById('vocabCard');
            const existingBadge = vocabCard.querySelector('.review-badge');
            if (existingBadge) existingBadge.remove();

            if (gameState.isReviewWord) {
                const badge = document.createElement('div');
                badge.className = 'review-badge';
                if (reviewType === 'learned') {
                    badge.textContent = 'ÂæóÊÑè';
                    badge.style.backgroundColor = '#4caf50'; // Green
                } else {
                    badge.textContent = 'Ëã¶Êâã';
                    badge.style.backgroundColor = '#f44336'; // Red
                }
                vocabCard.appendChild(badge);
            }

            // DOMÊõ¥Êñ∞Âæå„ÄÅÂ∞ë„ÅóÂæÖ„Å£„Å¶„Åã„ÇâÈü≥Â£∞ÂÜçÁîü
            setTimeout(() => {
                speakWord(word.word);
            }, 200);

            if (gameState.autoMode) {
                startAutoTimer();
            }

            checkLevelUp();
        }

        // NEW: Function to show a SPECIFIC word (for Undo/Restore)
        function showWord(word) {
            if (!word) return;

            // Reset Card State
            gameState.meaningCardFlipped = false;
            document.getElementById('meaningCard').classList.remove('flipped');

            // Map POS
            const posMap = {
                "Âêç": "ÂêçË©û",
                "Âãï": "ÂãïË©û",
                "ÂΩ¢": "ÂΩ¢ÂÆπË©û",
                "ÂâØ": "ÂâØË©û",
                "Âä©": "Âä©ÂãïË©û",
                "Êé•": "Êé•Á∂öË©û",
                "Ââç": "ÂâçÁΩÆË©û",
                "‰ª£": "‰ª£ÂêçË©û"
            };
            const fullPos = posMap[word.pos] || word.pos;

            // Update DOM (MATCHING showNextWord STRUCTURE EXACTLY)
            document.getElementById('vocabWord').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; transform: translateY(-10%);">
                    <div style="font-size: 18px; color: #667eea; font-weight: normal; margin-bottom: 5px;">${fullPos}</div>
                    <div style="font-size: 42px; font-weight: bold; line-height: 1.2;">${word.word}</div>
                </div>
            `;

            // Update Meaning (MATCHING showNextWord STRUCTURE)
            // Label Idea: Use English "Phrase" in small caps for a cleaner look
            const phraseLabel = `<span style="font-size: 11px; color: #999; text-transform: uppercase; letter-spacing: 1.5px; display: block; margin-bottom: 4px;">PHRASE</span>`;

            document.getElementById('meaningText').innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;">
                    <div style="font-size: 32px; font-weight: bold; color: #333; margin-bottom: 20px;">${word.meaning}</div>
                    ${word.phrase ? `
                        <div style="text-align: center; background: #f8f9fa; padding: 10px 20px; border-radius: 12px; border: 1px solid #eef0f5;">
                            ${phraseLabel}
                            <div style="font-size: 18px; color: #444; font-weight: 500;">${word.phrase}</div>
                        </div>
                    ` : ''}
                </div>
            `;

            document.getElementById('exampleSentence').textContent = word.example;

            // Re-bind speaker button for this word
            const speakerBtn = document.getElementById('speakerBtn');
            const newBtn = speakerBtn.cloneNode(true);
            speakerBtn.parentNode.replaceChild(newBtn, speakerBtn);

            newBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                speakText(word.example);
            });

            updateProgress();
        }

        function showNoWordsMessage() {
            const cardsArea = document.getElementById('cardsArea');
            const modeNames = {
                'unlearned': 'Êú™Â≠¶Áøí',
                'learned': 'ÂæóÊÑè',
                'perfect': 'ÂÆåÁíß',
                'weak': 'Ëã¶Êâã'
            };
            cardsArea.innerHTML = `<div class="no-words">„Åì„ÅÆ${modeNames[gameState.currentMode] || gameState.currentMode}„É¢„Éº„Éâ„Å´„ÅØÂçòË™û„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>`;
            document.getElementById('exampleArea').style.display = 'none';
        }

        function hideNoWordsMessage() {
            const cardsArea = document.getElementById('cardsArea');
            if (cardsArea.querySelector('.no-words')) {
                cardsArea.innerHTML = `
                    <div class="card vocab-card" id="vocabCard">
                        <div class="card-label">Ëã±ÂçòË™û„Ç´„Éº„Éâ</div>
                        <div class="card-content" id="vocabWord">Loading...</div>
                    </div>
                    <div class="card meaning-card" id="meaningCard">
                        <div class="card-label">ÊÑèÂë≥„Ç´„Éº„Éâ</div>
                        <div class="card-front">
                            <div class="card-content">‚ùì</div>
                        </div>
                        <div class="card-back">
                            <div class="card-content" id="meaningText">ÊÑèÂë≥</div>
                        </div>
                    </div>
                `;
                setupCardListeners();
            }
            document.getElementById('exampleArea').style.display = 'flex';
        }

        function clearAutoTimer() {
            if (autoTimer) {
                clearTimeout(autoTimer);
                autoTimer = null;
            }
        }

        function startAutoTimer() {
            clearAutoTimer();
            autoTimer = setTimeout(() => {
                if (!gameState.meaningCardFlipped && gameState.autoMode) {
                    autoOpenMeaningCard();
                }
            }, 3000);
        }

        function autoOpenMeaningCard() {
            const meaningCard = document.getElementById('meaningCard');
            if (!meaningCard || gameState.meaningCardFlipped) return;

            meaningCard.classList.add('flipped');
            gameState.meaningCardFlipped = true;

            const currentWord = gameState.currentWord;
            if (!currentWord) return;

            const key = getWordKey(currentWord, gameState.currentLevel);
            if (!gameState.isReviewWord && (gameState.currentMode === 'unlearned' || gameState.currentMode === 'weak')) {
                gameState.questionCount++;
            }

            gameState.wordStates[key] = 'weak';

            if (gameState.weakWordProgress[key]) {
                delete gameState.weakWordProgress[key];
            }

            const basePoints = 2;
            const finalPoints = basePoints * gameState.vocabLevel;
            gameState.points += finalPoints;

            showCoinPopup(finalPoints);
            updateDisplay();
            animateCharacter();
            saveGame();

            autoTimer = setTimeout(() => {
                if (gameState.autoMode) {
                    showNextWord();
                }
            }, 2000);
        }

        function setupCardListeners() {
            const vocabCard = document.getElementById('vocabCard');
            const meaningCard = document.getElementById('meaningCard');

            if (vocabCard) {
                vocabCard.addEventListener('click', handleVocabCardClick);
            }

            if (meaningCard) {
                meaningCard.addEventListener('click', handleMeaningCardClick);
            }
        }

        function handleVocabCardClick() {
            const currentWord = gameState.currentWord;
            if (!currentWord) return;

            clearAutoTimer();

            // Ignore click if card is already flipped (user should click Next or Meaning card)
            // Actually, if flipped, clicking vocab card usually means "Next" in this design?
            // User said: "Click vocab card = Correct".
            // If already flipped, maybe "Correct" doesn't make sense anymore because they saw the answer.
            // But let's assume clicking Vocab Card (Front) is the primary "I know this" action.
            // If flipped, it's hidden behind checks usually. 
            // In the provided code, vocabCard is FRONT. meaningCard is BACK.
            // If flipped, Vocab Card is HIDDEN.
            // So this handler only fires if NOT flipped.

            if (gameState.meaningCardFlipped) {
                // Should not happen if UI hides it, but safety:
                showNextWord();
                return;
            }

            // Save state for Undo
            saveState();

            const key = getWordKey(currentWord, gameState.currentLevel);
            let basePoints = 1;
            let msg = "";

            // LOGIC: Unlearned -> Perfect, Weak -> Learned, Learned -> Perfect, Perfect -> Perfect
            const currentState = gameState.wordStates[key];

            if (currentState === 'unlearned') {
                gameState.wordStates[key] = 'perfect';
                gameState.wordsLearned++;
                checkLevelUp();
            } else if (currentState === 'weak') {
                gameState.wordStates[key] = 'learned';
                basePoints = 2; // User Request: 2 points for weak (Priority)
                msg = "‚úÖ ÂÖãÊúçÔºÅ";
                if (gameState.weakWordProgress[key]) delete gameState.weakWordProgress[key];
                gameState.learnedWordIntervals[key] = 0;
                gameState.learnedWordIntervals[`${key}_last`] = gameState.globalQuestionCount;
            } else if (currentState === 'learned') {
                gameState.wordStates[key] = 'perfect';
                basePoints = 1; // Default 1
                msg = "üèÜ ÂÆåÁíß„Éû„Çπ„Çø„ÉºÔºÅ";
            } else if (currentState === 'perfect') {
                // Stay perfect
                basePoints = 1; // Default 1
                msg = "‚ú® ÂÆåÁíßÁ∂≠ÊåÅÔºÅ";
            } else {
                // Fallback
                gameState.wordStates[key] = 'perfect';
                basePoints = 1;
            }

            const finalPoints = basePoints * gameState.vocabLevel;
            gameState.points += finalPoints;

            // RPG Animation Trigger
            // RPG Animation Trigger
            if (currentState === 'weak') {
                playAnimation('attack'); // Weakness Overcome -> Battle
                //} else if (msg.includes('ÂÆåÁíß')) {
                //    // Perfect -> Victory
                //    playAnimation('victory');
            } else {
                playAnimation('idle'); // Standard
            }

            showCoinPopup(finalPoints); // Optionally show text? Currently logic only shows number.

            updateDisplay();
            showNextWord();
            animateCharacter();
            saveGame();
        }

        function handleMeaningCardClick(e) {
            const card = e.currentTarget;
            clearAutoTimer();

            if (!gameState.meaningCardFlipped) {
                // Save state for Undo
                saveState();

                // Flip = Incorrect / Check
                card.classList.add('flipped');
                gameState.meaningCardFlipped = true;

                const currentWord = gameState.currentWord;
                if (!currentWord) return;

                const key = getWordKey(currentWord, gameState.currentLevel);
                const currentState = gameState.wordStates[key];

                // LOGIC: Learned -> Weak. Unlearned -> Weak. Perfect -> Learned (Soft landing).

                if (currentState === 'perfect') {
                    gameState.wordStates[key] = 'learned';
                    // Reset learned interval as it's a "new" learned word effectively
                    gameState.learnedWordIntervals[key] = 0;
                    gameState.learnedWordIntervals[`${key}_last`] = gameState.globalQuestionCount;
                } else if (currentState === 'learned') {
                    gameState.wordStates[key] = 'weak';
                } else if (currentState === 'unlearned') {
                    gameState.wordStates[key] = 'weak';
                    gameState.wordsLearned++;
                    checkLevelUp();
                }
                // If already weak, stay weak.

                // Points Logic: Unlearned=1, Weak=2, Others=1
                let basePoints = 1;
                if (currentState === 'weak') {
                    basePoints = 2;
                } else if (currentState === 'unlearned') {
                    basePoints = 1;
                } else {
                    basePoints = 1;
                }
                const finalPoints = basePoints * gameState.vocabLevel;
                gameState.points += finalPoints;

                // showCoinPopup(finalPoints); // Maybe don't show popup for "Incorrect"? 
                // Let's keep it positive. Learning is earning.

                updateDisplay();
                animateCharacter();
                saveGame();
            } else {
                // If already flipped, clicking it again = Next Word
                showNextWord();
            }
        }

        // ... checkLevelUp ...
        // ... addNextWordSet ...

        // FIX: Remove legacy function inside loop or whatever caused issues

        function checkLevelUp() {
            const unlearnedCount = getWordsByMode('unlearned').length;
            const addWordsContainer = document.getElementById('addWordsContainer');
            if (!addWordsContainer) return;

            let maxSet = 0;
            if (vocabularyDatabase[gameState.currentLevel] && vocabularyDatabase[gameState.currentLevel].length > 0) {
                maxSet = Math.max(...vocabularyDatabase[gameState.currentLevel].map(v => v.set));
            }

            if (unlearnedCount === 0 && gameState.vocabLevel < maxSet) {
                addWordsContainer.style.display = 'block';
            } else {
                addWordsContainer.style.display = 'none';
            }
        }

        function addNextWordSet() {
            let maxSet = 0;
            if (vocabularyDatabase[gameState.currentLevel] && vocabularyDatabase[gameState.currentLevel].length > 0) {
                maxSet = Math.max(...vocabularyDatabase[gameState.currentLevel].map(v => v.set));
            }
            if (gameState.vocabLevel >= maxSet) {
                alert('„Åô„Åß„Å´ÂÖ®„Å¶„ÅÆ„Çª„ÉÉ„Éà„ÅåËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„ÅôÔºÅ');
                return;
            }

            gameState.vocabLevel++;
            loadVocabularyForLevel();
            initializeWordStates();
            showCoinPopup(`üéâ „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºÅË™ûÂΩô„É¨„Éô„É´ ${gameState.vocabLevel}`, true);
            updateDisplay();
            saveGame();
            showNextWord();
        }

        function animateCharacter() {
            // Character UI removed. No-op.
        }

        function updateDisplay() {
            const rawPoints = Math.floor(gameState.points);
            let displayPoints = rawPoints;
            if (rawPoints >= 100000) {
                // 100k notation
                displayPoints = Math.floor(rawPoints / 1000) + 'k';
            }
            document.getElementById('points').textContent = displayPoints;
            updateWordStats();
            updateWordStats();
            updateModeButtons();
            updateProgress();
        }

        // --- RPG Animation Logic ---
        // --- RPG Animation Logic ---
        let animTimer = null;

        function playAnimation(type) {
            const hero = document.getElementById('heroCharacter');
            const slime = document.getElementById('enemySlime');

            // Clear previous timers to prevent overlap
            if (animTimer) {
                clearTimeout(animTimer);
                animTimer = null;
            }

            // Default State: Idle (Row 1), Slime hidden
            // Reset to ensure clean transition
            hero.className = 'pixel-art';

            if (type === 'idle') {
                hero.classList.add('anim-idle');
                slime.style.opacity = '0';
                return;
            }

            if (type === 'attack') {
                hero.className = 'pixel-art anim-attack';
                slime.className = 'pixel-art anim-slime'; // Ensure animation runs
                slime.style.opacity = '1';

                // Duration: 0.8s * 2 loops = 1600ms
                animTimer = setTimeout(() => {
                    // Revert to Idle
                    hero.className = 'pixel-art anim-idle';
                    // Hide Slime
                    slime.style.opacity = '0';
                }, 1600);

            } else if (type === 'victory') {
                hero.className = 'pixel-art anim-cheer';
                // Slime should be hidden
                slime.style.opacity = '0';

                // Duration: 0.8s * 2 loops = 1600ms
                animTimer = setTimeout(() => {
                    hero.className = 'pixel-art anim-idle';
                }, 1600);
            }
        }

        function getCategoryLevel(category) {
            // Fix: Iterate over the actual vocabulary list for this category
            // instead of relying on key prefixes (which fail for referenced words).
            const words = vocabularyDatabase[category] || [];
            let count = 0;

            words.forEach(word => {
                // Use the shared helper to get the correct key (handles refs)
                const key = getWordKey(word, category);
                const state = gameState.wordStates[key];
                if (state === 'learned' || state === 'perfect' || state === 'weak') {
                    count++;
                }
            });

            return Math.floor(count / 20) + 1;
        }

        function updateProgress() {
            // Calculate Progress based on Valid Words in current level
            const validWords = vocabulary; // Currently loaded vocabulary array
            if (!validWords || validWords.length === 0) {
                document.querySelectorAll('.js-progress-percent').forEach(el => el.textContent = "0");
                document.querySelectorAll('.js-progress-bar-fill').forEach(el => el.style.width = "0%");
            } else {
                const total = validWords.length;
                const learnedCount = getWordsByMode('learned').length;
                const perfectCount = getWordsByMode('perfect').length;
                const learnedTotal = learnedCount + perfectCount;

                const percent = Math.floor((learnedTotal / total) * 100);

                // Update DOM - Support multiple instances (PC/Mobile)
                document.querySelectorAll('.js-progress-percent').forEach(el => el.textContent = percent);
                document.querySelectorAll('.js-progress-bar-fill').forEach(el => el.style.width = `${percent}%`);

                // Determine Title (Mage Theme) based on percentage
                let title = "Ë¶ãÁøí„ÅÑÈ≠îË°ìÂ∏´"; // 0-9
                if (percent >= 100) title = "È≠îÊ≥ï„ÅÆÁ•û";
                else if (percent >= 90) title = "Ë≥¢ËÄÖ";
                else if (percent >= 70) title = "Â§ßÈ≠îÂ∞éÂ£´";
                else if (percent >= 50) title = "ÁéãÂÆÆÈ≠îË°ìÂ∏´";
                else if (percent >= 30) title = "ÊâãÁ∑¥„Çå„ÅÆÈ≠îÂ∞éÂ£´";
                else if (percent >= 10) title = "ÈßÜ„ÅëÂá∫„Åó„ÅÆÈ≠îÊ≥ï‰Ωø„ÅÑ";

                document.querySelectorAll('.js-current-title').forEach(el => el.textContent = title);
            }

            // --- World Level Calculation ---
            // Sum of levels from Junior, Basic, Daily, Exam1
            const categories = ['junior', 'basic', 'daily', 'exam1'];
            let worldLevel = 0;
            categories.forEach(cat => {
                worldLevel += getCategoryLevel(cat);
            });

            // Update Game State
            gameState.vocabLevel = worldLevel;

            // Update World Level Display (Support multiple instances)
            document.querySelectorAll('.js-vocab-level-value').forEach(el => {
                el.textContent = worldLevel;
            });

            // --- Local Level Calculation (for current category) ---
            const localLevel = getCategoryLevel(gameState.currentLevel);
            document.querySelectorAll('.js-local-level-value').forEach(el => {
                el.textContent = localLevel;
            });

            const vocabLevelDisplay = document.getElementById('vocabLevelDisplay');
            if (vocabLevelDisplay) {
                vocabLevelDisplay.textContent = worldLevel;
            }

            // Update Label to "„ÉØ„Éº„É´„Éâ„É¨„Éô„É´"
            const labelContainer = document.querySelector('.vocab-level-display');
            if (labelContainer && labelContainer.childNodes[0].nodeType === 3) {
                labelContainer.childNodes[0].textContent = "„ÉØ„Éº„É´„Éâ„É¨„Éô„É´: ";
            }

            // --- Local Level Calculation ---
            // Level for the current category
            const currentLocalLevel = getCategoryLevel(gameState.currentLevel);

            const titleDisplay = document.querySelector('.title-display');
            if (titleDisplay) {
                // Removed Lv display appending as per user request
                let levelSpan = document.getElementById('playerLevelDisplay');
                if (levelSpan) {
                    levelSpan.style.display = 'none'; // Ensure hidden if it exists
                }
            }
        }



        function updateWordStats() {
            // Unlearned
            document.getElementById('unlearnedCount').textContent = getWordsByMode('unlearned').length;
            // Learned
            document.getElementById('learnedCount').textContent = getWordsByMode('learned').length;
            // Perfect (New)
            document.getElementById('perfectCount').textContent = getWordsByMode('perfect').length;
            // Weak
            document.getElementById('weakCount').textContent = getWordsByMode('weak').length;
        }

        function updateModeButtons() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === gameState.currentMode) {
                    btn.classList.add('active');
                }
            });

            if (gameState.randomMode) {
                document.getElementById('randomCheckbox').classList.add('checked');
                // document.getElementById('randomNotice').style.display = 'inline'; // Removed as requested
                // Disable mode buttons visually
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.add('disabled');
                });
            } else {
                document.getElementById('randomCheckbox').classList.remove('checked');
                document.getElementById('randomNotice').style.display = 'none';
                // Enable mode buttons
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('disabled');
                });
            }

            if (gameState.autoMode) {
                document.getElementById('autoCheckbox').classList.add('checked');
            } else {
                document.getElementById('autoCheckbox').classList.remove('checked');
            }
        }

        function showCoinPopup(amount, isLevelUp = false) {
            // Disable normal gold popups (User Request)
            if (!isLevelUp) return;

            const popup = document.createElement('div');
            popup.className = 'coin-popup';

            if (isLevelUp) {
                popup.textContent = amount;
            } else {
                popup.textContent = `+${Math.floor(amount)} gold`;
            }

            document.body.appendChild(popup);

            setTimeout(() => {
                popup.remove();
            }, 600);
        }

        // --- SIMPLE MODE LOGIC ---
        function openSimpleModeModal() {
            document.getElementById('simpleModeModal').style.display = 'flex';
        }

        function startSimpleMode(level) {
            document.getElementById('simpleModeModal').style.display = 'none';
            document.body.classList.add('simple-mode');

            if (level === 'wordbook') {
                // Open Wordbook Selection Modal
                // Assuming openWordbookModal() exists or we find the logic.
                // Re-using existing button click logic is safest if function undefined.
                const wbBtn = document.getElementById('wordbookBtn');
                if (wbBtn) wbBtn.click();
            } else {
                // Set Level
                const btn = document.querySelector(`.level-btn[data-level="${level}"]`);
                if (btn) btn.click();
            }
        }

        function exitSimpleMode() {
            document.body.classList.remove('simple-mode');
        }

        // --- Leaderboard & Cloud Modal UI Logic (Moved from Module) ---
        function openLeaderboard() {
            document.getElementById('leaderboardModal').style.display = 'flex';

            // Check Auth State (Global auth object exposed in window.firebaseAuth)
            const currentUser = window.firebaseAuth ? window.firebaseAuth.currentUser : null;

            if (!currentUser) {
                // Not Logged In
                document.getElementById('loginRequiredMessage').style.display = 'block';
                document.getElementById('nameInputParams').style.display = 'none';
                document.getElementById('leaderboardContent').style.display = 'none';
                document.getElementById('renameBtn').style.display = 'none';
            } else {
                // Logged In
                document.getElementById('loginRequiredMessage').style.display = 'none';
                checkNameRegistration();
            }
        }

        function closeLeaderboard() {
            document.getElementById('leaderboardModal').style.display = 'none';
        }

        function openCloudModal() {
            document.getElementById('cloudModal').style.display = 'flex';
        }

        let playerName = localStorage.getItem('vocabGame_playerName');
        let lastSyncTime = 0;

        function checkNameRegistration() {
            if (!playerName) {
                document.getElementById('nameInputParams').style.display = 'block';
                document.getElementById('leaderboardContent').style.display = 'none';
                document.getElementById('renameBtn').style.display = 'none';
            } else {
                document.getElementById('nameInputParams').style.display = 'none';
                document.getElementById('leaderboardContent').style.display = 'block';
                document.getElementById('renameBtn').style.display = 'block';

                // Sync Score (attempt)
                if (typeof attemptScoreSync === 'function') attemptScoreSync(true);
                loadRankingData('top');
            }
        }

        function renamePlayer() {
            // Store current name temporarily in case of cancel
            document.getElementById('playerNameInput').value = playerName;

            // Show input, hide content
            document.getElementById('nameInputParams').style.display = 'block';
            document.getElementById('leaderboardContent').style.display = 'none';
            document.getElementById('renameBtn').style.display = 'none';

            // Show cancel button
            document.getElementById('cancelRenameBtn').style.display = 'inline-block';
        }

        function cancelRename() {
            checkNameRegistration(); // Restore view
        }

        function registerName() {
            const input = document.getElementById('playerNameInput');
            const val = input.value.trim();
            if (val.length > 0 && val.length <= 8) {
                playerName = val;
                localStorage.setItem('vocabGame_playerName', playerName);

                // Sync Score (attempt)
                if (typeof attemptScoreSync === 'function') attemptScoreSync(true);
                checkNameRegistration();
            } else {
                alert("ÂêçÂâç„ÅØ1„Äú8ÊñáÂ≠ó„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
            }
        }

        // Global function for saveGame hook
        window.attemptScoreSync = function (force = false) {
            if (!playerName) return;
            const now = Date.now();
            if (force || (now - lastSyncTime > 60000)) {
                if (window.uploadScore) {
                    window.uploadScore(playerName, gameState.points);
                    lastSyncTime = now;
                }
            }
        };

        // Fallback Stubs for Cloud Functions (in case module fails to load)
        if (!window.uploadSaveData) {
            window.uploadSaveData = function () { alert("Ê©üËÉΩ„ÅÆË™≠„ÅøËæº„Åø‰∏≠„ÄÅ„Åæ„Åü„ÅØÈÄö‰ø°Áí∞Â¢É„Å´„Çà„ÇäÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ\n(„É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„ÅßÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÂãï‰Ωú„Åó„Å™„ÅÑ„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô)"); };
        }
        if (!window.restoreSaveData) {
            window.restoreSaveData = function () { alert("Ê©üËÉΩ„ÅÆË™≠„ÅøËæº„Åø‰∏≠„ÄÅ„Åæ„Åü„ÅØÈÄö‰ø°Áí∞Â¢É„Å´„Çà„ÇäÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"); };
        }

        function switchTab(tab) {
            document.querySelectorAll('.lb-tab').forEach(b => b.classList.remove('active'));
            const buttons = document.querySelectorAll('.lb-tab');
            if (buttons.length > 0) {
                if (tab === 'top') buttons[0].classList.add('active');
                else if (buttons[1]) buttons[1].classList.add('active');
            }

            document.getElementById('lb-list-top').style.display = (tab === 'top') ? 'block' : 'none';
            document.getElementById('lb-list-around').style.display = (tab === 'around') ? 'block' : 'none';

            loadRankingData(tab);
        }

        async function loadRankingData(type) {
            const container = (type === 'top') ? document.getElementById('lb-list-top') : document.getElementById('lb-list-around');
            container.innerHTML = '<div style="padding:10px; color:#999;">„Éá„Éº„ÇøÂèñÂæó‰∏≠...</div>';

            if (window.fetchLeaderboard) {
                const data = await window.fetchLeaderboard(type);

                if (data.error) {
                    container.innerHTML = `<div style="color:red; padding:10px;">„Ç®„É©„Éº: ${data.error}</div>`;
                    return;
                }

                if (!data.results || data.results.length === 0) {
                    container.innerHTML = `<div style="padding:10px;">„É©„É≥„Ç≠„É≥„Ç∞„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>`;
                    return;
                }

                let html = '';
                data.results.forEach(item => {
                    const rankDisplay = (typeof item.rank === 'number') ? item.rank : item.rank;
                    const isTop3 = (typeof item.rank === 'number' && item.rank <= 3);

                    html += `
                    <div class="ranking-item ${item.isMe ? 'is-me' : ''}">
                        <span class="rank-num ${isTop3 ? 'top3' : ''}">${rankDisplay}</span>
                        <span class="rank-name">${escapeHtml(item.name)}</span>
                        <span class="rank-score">${item.score.toLocaleString()} G</span>
                    </div>`;
                });
                container.innerHTML = html;
            } else {
                container.innerHTML = `<div style="padding:10px;">Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì („Ç™„Éï„É©„Ç§„É≥)</div>`;
            }
            document.getElementById('lb-loading').style.display = 'none';
        }

        function escapeHtml(str) {
            if (!str) return "";
            return str.replace(/[&<>"']/g, function (m) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#039;'
                }[m];
            });
        }

        init();
        initTrialSystem(); // Start Trial Timer
    </script>
    <!-- Simple Mode Category Selection Modal -->
    <div id="simpleModeModal" class="modal-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10001; justify-content: center; align-items: center;">
        <div class="modal-content"
            style="background: white; padding: 30px; border-radius: 12px; max-width: 90%; width: 400px; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.3);">
            <h2 style="margin-top: 0; color: #333; margin-bottom: 20px;">üì± „Ç∑„É≥„Éó„É´„É¢„Éº„ÉâË®≠ÂÆö</h2>
            <p style="color: #666; margin-bottom: 20px; font-size: 14px;">Âá∫È°åÁØÑÂõ≤„ÇíÈÅ∏Êäû„Åó„Å¶„Çπ„Çø„Éº„ÉàÔºÅ</p>

            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button onclick="startSimpleMode('junior')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-weight: bold; color: #333;">üî∞
                    ‰∏≠Â≠¶„É¨„Éô„É´</button>
                <button onclick="startSimpleMode('basic')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-weight: bold; color: #333;">üìö
                    Âü∫Á§é„É¨„Éô„É´</button>
                <button onclick="startSimpleMode('daily')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-weight: bold; color: #333;">üé¨
                    Ê®ôÊ∫ñ„É¨„Éô„É´</button>
                <button onclick="startSimpleMode('exam1')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-weight: bold; color: #333;">üìñ
                    ÂèóÈ®ì„É¨„Éô„É´</button>
                <!-- Wordbook Option -->
                <button onclick="startSimpleMode('wordbook')" class="simple-select-btn"
                    style="padding: 12px; border: 1px solid #ddd; border-radius: 8px; background: linear-gradient(135deg, #6c5ce7, #a29bfe); color: white; cursor: pointer; font-weight: bold;">üìò
                    ÂçòË™ûÂ∏≥</button>
            </div>

            <button onclick="document.getElementById('simpleModeModal').style.display='none'"
                style="margin-top: 20px; background: none; border: none; color: #999; text-decoration: underline; cursor: pointer;">„Ç≠„É£„É≥„Çª„É´</button>
        </div>
    </div>

    <!-- Simple Mode Exit Button (Hidden by default) -->
    <button id="exitSimpleModeBtn" onclick="exitSimpleMode()"
        style="display: none; position: fixed; top: 15px; right: 15px; z-index: 300; background: #333; color: white; border: none; padding: 5px 12px; border-radius: 20px; font-size: 12px; cursor: pointer; opacity: 0.8;">
        ‚úï ÈÄöÂ∏∏„É¢„Éº„Éâ„Å∏Êàª„Çã
    </button>

    <!-- Help Modal -->
    <div id="helpModal" class="modal-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 10000; justify-content: center; align-items: center;">
        <div class="modal-content"
            style="background: white; padding: 25px; border-radius: 15px; max-width: 90%; width: 450px; text-align: left; box-shadow: 0 10px 30px rgba(0,0,0,0.3); position: relative;">
            <button id="closeHelpModal"
                style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: #888;">&times;</button>
            <h2
                style="margin-top: 0; border-bottom: 2px solid #ddd; padding-bottom: 10px; color: #6c5ce7; text-align: center;">
                ÈÅä„Å≥Êñπ„Ç¨„Ç§„Éâ</h2>

            <div style="font-weight: bold; margin-top: 15px; color: #333;">„ÄêÊåáÈáù„ÄëÂæóÊÑèÂçòË™û„Å®Ëã¶ÊâãÂçòË™û„Çí‰ªïÂàÜ„Åë„Å¶„Åè„Å†„Åï„ÅÑ</div>
            <ul style="margin: 10px 0 20px 0; padding-left: 20px; color: #444; line-height: 1.8; font-size: 15px;">
                <li>ÊÑèÂë≥„Åå„Çè„Åã„Çã‚Üí„ÄåÂçòË™û„Ç´„Éº„Éâ„Äç„Çí„Çø„ÉÉ„Éó</li>
                <li>„Çè„Åã„Çâ„Å™„ÅÑ‚Üí„ÄåÊÑèÂë≥„Ç´„Éº„Éâ„Äç„Çí„Çø„ÉÉ„Éó</li>
                <li>ÊÑèÂë≥„Ç´„Éº„Éâ„Çí„Çø„ÉÉ„Éó‚Üí„Åù„ÅÆÂçòË™û„ÅØ„ÄåËã¶Êâã„Çæ„Éº„É≥„Äç„Å∏</li>
                <!-- Removed items as requested -->
                <li>1Êó•10ÂàÜ„ÅÆÂà∂Èôê„ÅØ„ÄÅNoteÁâπÂÖ∏„ÅÆ„Éë„Çπ„ÉØ„Éº„Éâ„ÅßËß£Èô§ÂèØËÉΩ</li>
            </ul>
            <div style="text-align: center; margin-bottom: 20px;">
                <span style="font-size: 15px; color: #444;">Ëß£Èô§„ÅØ</span>
                <button onclick="showLockScreen(); document.getElementById('helpModal').style.display='none';"
                    style="background: none; border: none; color: #667eea; text-decoration: underline; cursor: pointer; font-size: 16px; font-weight: bold;">
                    „Ç≥„ÉÅ„É©
                </button>
                <span style="font-size: 15px; color: #444;">„Åã„Çâ</span>
            </div>

            <div style="text-align: center; margin-top: 25px;">
                <a href="https://note.com/tenioha_eng/n/n5918d72138bd?sub_rt=share_pb" target="_blank"
                    style="display: inline-block; background: #00b894; color: white; padding: 12px 25px; text-decoration: none; border-radius: 25px; font-weight: bold; box-shadow: 0 4px 6px rgba(0,0,0,0.1); transition: transform 0.2s;">
                    üìö Ë©≥„Åó„ÅÑ‰Ωø„ÅÑÊñπ„ÅØ„Åì„Å°„Çâ (Note)
                </a>
                </a>
            </div>

            <!-- PWA Install Button (Visible but Gray by default) -->
            <div id="installAppContainer" style="margin-top: 15px; text-align: center;">
                <button id="pwaInstallBtn"
                    style="background: #bdc3c7; color: white; border: none; padding: 10px 20px; border-radius: 20px; font-weight: bold; cursor: not-allowed; box-shadow: none; width: 80%;">
                    üì≤ „Ç¢„Éó„É™„Å®„Åó„Å¶„Ç§„É≥„Çπ„Éà„Éº„É´
                </button>
                <p id="pwaInstallDesc" style="font-size: 11px; color: #999; margin-top: 5px;">Ê∫ñÂÇô‰∏≠„ÄÅ„Åæ„Åü„ÅØ„Éñ„É©„Ç¶„Ç∂„ÅÆ„É°„Éã„É•„Éº„Åã„ÇâËøΩÂä†</p>
            </div>

            <div style="margin-top: 15px; text-align: center;">
                <p style="font-size: 12px; color: #666;">„ÅäÂïè„ÅÑÂêà„Çè„Åõ„Éª„Éê„Ç∞Â†±Âëä</p>
                <a href="mailto:tenioha.eng@gmail.com"
                    style="display: inline-block; margin-top: 5px; color: #6c5ce7; font-weight: bold; text-decoration: underline;">
                    üìß tenioha.eng@gmail.com
                </a>
            </div>

            <div
                style="text-align: right; margin-top: 10px; padding-right: 5px; display: flex; justify-content: flex-end; align-items: center; gap: 10px;">
                <button onclick="forceUpdateApp()"
                    style="background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; padding: 2px 8px; font-size: 10px; color: #555; cursor: pointer;">
                    üîÑ ÊúÄÊñ∞Áâà„Å∏Êõ¥Êñ∞
                </button>
                <span style="font-size: 11px; color: #ccc;">v1.30</span>
            </div>




        </div>
    </div>

    <script>
        // Force Update Logic
        async function forceUpdateApp() {
            if (!confirm("„Ç¢„Éó„É™„ÇíÊúÄÊñ∞Áâà„Å´Êõ¥Êñ∞„Åó„Å¶„É™„É≠„Éº„Éâ„Åó„Åæ„Åô„ÅãÔºü\n(Êú™‰øùÂ≠ò„ÅÆ„Éó„É¨„Ç§„Éá„Éº„Çø„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂÖà„Å´‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑ)")) return;

            try {
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    for (let registration of registrations) {
                        await registration.unregister();
                    }
                }
                // Optional: Clear Cache API?
                // const keys = await caches.keys();
                // await Promise.all(keys.map(key => caches.delete(key)));

                // Hard Reload
                window.location.reload(true);
            } catch (e) {
                console.error("Update failed:", e);
                window.location.reload();
            }
        }
    </script>
    </div>
    <div id="wordbookModal" class="modal-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div class="modal-content"
            style="background: white; padding: 20px; border-radius: 12px; max-width: 90%; width: 400px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <h2 style="margin-top: 0; color: #333;">ÂçòË™ûÂ∏≥„ÇíÈÅ∏Êäû</h2>
            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                <button class="wordbook-item-btn" data-level="selection1900"
                    style="padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-size: 16px; font-weight: bold; color: #555; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <span style="font-size: 24px;">ü¶ñ</span> Âé≥ÈÅ∏ 1900+
                </button>
                <button class="wordbook-item-btn" data-level="selection1400"
                    style="padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-size: 16px; font-weight: bold; color: #555; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <span style="font-size: 24px;">üêï</span> Âé≥ÈÅ∏ 1400+
                </button>
                <button class="wordbook-item-btn" data-level="sys_2000"
                    style="padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa; cursor: pointer; font-size: 16px; font-weight: bold; color: #555; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <span style="font-size: 24px;">üíª</span> „Ç∑„Çπ„ÉÜ„É†WORDS (2077Ë™û)
                </button>
                <!-- Future wordbooks can be added here -->
            </div>
            <button id="closeWordbookModal"
                style="margin-top: 20px; padding: 8px 20px; border: none; background: #ddd; border-radius: 5px; cursor: pointer;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" class="modal-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 10002; justify-content: center; align-items: center;">
        <div class="modal-content"
            style="background: white; padding: 25px; border-radius: 15px; max-width: 90%; width: 450px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3); position: relative;">
            <button onclick="closeLeaderboard()"
                style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: #888;">&times;</button>

            <!-- Rename Button (Top Left) -->
            <button id="renameBtn" onclick="renamePlayer()"
                style="position: absolute; top: 15px; left: 15px; background: none; border: 1px solid #ccc; border-radius: 4px; padding: 2px 8px; font-size: 11px; cursor: pointer; color: #888; display: none;">
                ‚úèÔ∏è ÂêçÂâçÂ§âÊõ¥
            </button>

            <h2 style="margin-top: 0; padding-bottom: 10px; color: #f1c40f; text-shadow: 1px 1px 0px #e67e22;">
                üèÜ „É©„É≥„Ç≠„É≥„Ç∞
            </h2>

            <!-- Login Required Message (New) -->
            <div id="loginRequiredMessage" style="display: none; padding: 20px;">
                <p style="font-size: 16px; color: #555; font-weight: bold; margin-bottom: 10px;">
                    Êú™„É≠„Ç∞„Ç§„É≥„ÅÆ„Åü„ÇÅ„ÄÅÈñ≤Ë¶ß‰∏çÂèØ
                </p>
                <p style="font-size: 12px; color: #888; margin-bottom: 20px;">
                    „É©„É≥„Ç≠„É≥„Ç∞Ê©üËÉΩ„ÇíÂà©Áî®„Åô„Çã„Å´„ÅØ<br>Google„Ç¢„Ç´„Ç¶„É≥„Éà„Åß„ÅÆ„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ
                </p>
                <button onclick="closeLeaderboard(); openProfileModal();"
                    style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: bold; cursor: pointer;">
                    „É≠„Ç∞„Ç§„É≥ÁîªÈù¢„Å∏ÁßªÂãï
                </button>
            </div>

            <!-- Name Input Overlay (Initial Only) -->
            <!-- Name Input Overlay (Initial Only) -->
            <div id="nameInputParams" style="display: none; margin-bottom: 20px;">
                <p style="font-size: 14px; color: #666; margin-bottom: 10px;">„É©„É≥„Ç≠„É≥„Ç∞„Å´ÂèÇÂä†„Åô„Çã„Å´„ÅØÂêçÂâç„ÇíÁôªÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                <input type="text" id="playerNameInput" placeholder="„Éã„ÉÉ„ÇØ„Éç„Éº„É†ÔºàÔºòÊñáÂ≠ó‰ª•ÂÜÖÔºâ" maxlength="8"
                    style="padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: 70%; text-align: center;">
                <div style="margin-top: 10px;">
                    <button onclick="registerName()"
                        style="padding: 8px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">ÁôªÈå≤„Åó„Å¶ÂèÇÂä†</button>
                    <button id="cancelRenameBtn" onclick="cancelRename()"
                        style="display: none; padding: 8px 15px; background: #ddd; color: #555; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">„Ç≠„É£„É≥„Çª„É´</button>
                </div>
            </div>

            <!-- Tab Content -->
            <div id="leaderboardContent" style="display: none;">
                <div class="leaderboard-tabs">
                    <button class="lb-tab active" onclick="switchTab('top')">TOP 20</button>
                    <button class="lb-tab" onclick="switchTab('around')">Ëá™ÂàÜ„ÅÆÈ†Ü‰Ωç</button>
                </div>

                <div id="lb-loading" style="color: #999; padding: 20px;">Ë™≠„ÅøËæº„Åø‰∏≠...</div>

                <div id="lb-list-top" class="ranking-list">
                    <!-- Dynamic Content -->
                    <div class="ranking-item">
                        <span class="rank-num top3">1</span>
                        <span class="rank-name">No Data</span>
                        <span class="rank-score">- G</span>
                    </div>
                </div>

                <div id="lb-list-around" class="ranking-list" style="display: none;">
                    <!-- Users + Neighbors -->
                </div>
            </div>
        </div>
    </div>

    <!-- Cloud Data Modal -->
    <!-- Profile Modal (New Hub) -->
    <div id="profileModal" class="modal-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 10002; justify-content: center; align-items: flex-start; padding-top: 50px; overflow-y: auto;">
        <div class="modal-content"
            style="background: white; padding: 25px; border-radius: 15px; max-width: 90%; width: 400px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3); position: relative; margin-bottom: 50px;">
            <button onclick="closeProfileModal()"
                style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: #888;">&times;</button>

            <h2 style="margin-top: 20px; color: #667eea; margin-bottom: 20px;">„Éû„Ç§„Éö„Éº„Ç∏</h2>

            <!-- User Info Section -->
            <div
                style="background: #f8f9fa; padding: 20px; border-radius: 15px; margin-bottom: 20px; text-align: center;">
                <div
                    style="width: 80px; height: 80px; margin: 0 auto 10px; border-radius: 50%; background: #eee; overflow: hidden; border: 3px solid white; box-shadow: 0 4px 10px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center;">
                    <img id="modalProfileImage" src=""
                        style="width: 100%; height: 100%; object-fit: cover; display: none;">
                    <span id="modalProfileInitials" style="font-size: 32px;">üë§</span>
                </div>
                <div id="modalUserName" style="font-weight: bold; font-size: 18px; color: #333;">„Ç≤„Çπ„Éà„É¶„Éº„Ç∂„Éº</div>
                <div id="modalUserEmail" style="font-size: 12px; color: #888; margin-bottom: 10px;">Êú™„É≠„Ç∞„Ç§„É≥</div>

                <!-- Plan Status -->
                <div id="planStatusTag"
                    style="display: inline-block; padding: 5px 15px; background: #95a5a6; color: white; border-radius: 20px; font-size: 12px; font-weight: bold;">
                    ÁÑ°Êñô„Éó„É©„É≥ (Âà∂Èôê„ÅÇ„Çä)
                </div>
                <!-- Premium Activation Section (Hidden if Premium) -->
                <div id="premiumActivationSection"
                    style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px;">
                    <div style="font-size: 14px; font-weight: bold; color: #333; margin-bottom: 5px;">üíé „Éó„É¨„Éü„Ç¢„É†ÊúâÂäπÂåñ</div>
                    <div style="display: flex; gap: 5px;">
                        <input type="text" id="promoCodeInput" placeholder="„Éó„É≠„É¢„Ç≥„Éº„Éâ"
                            style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;">
                        <button onclick="redeemPromoCode()"
                            style="padding: 8px 12px; background: #2ecc71; color: white; border: none; border-radius: 5px; font-weight: bold; cursor: pointer;">
                            ÊúâÂäπÂåñ
                        </button>
                    </div>
                    <div style="font-size: 10px; color: #999; margin-top: 5px; text-align: left;">
                        ‚ÄªË≥ºÂÖ•„Åó„Åü„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åô„Çã„Å®„ÄÅ„Éó„É¨„Éü„Ç¢„É†Ê©üËÉΩ„ÅåËß£Êîæ„Åï„Çå„Åæ„Åô„ÄÇ
                    </div>
                </div>
            </div>

            <!-- Action List -->
            <div style="display: flex; flex-direction: column; gap: 10px; text-align: left;">

                <div id="profileSyncSection"
                    style="display: none; background: #eef2ff; padding: 15px; border-radius: 10px; margin-bottom: 10px;">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-size: 14px; font-weight: bold; color: #333;">‚òÅÔ∏è „Éá„Éº„Çø„ÅÆÂêåÊúü</span>
                        <span id="profileLastSync" style="font-size: 11px; color: #666;">-</span>
                    </div>

                    <div style="display: flex; gap: 10px;">
                        <button onclick="forceBackup()"
                            style="flex: 1; padding: 8px; background: #6c5ce7; color: white; border: none; border-radius: 5px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 5px;">
                            ‚¨ÜÔ∏è ÊâãÂãï„Çª„Éº„Éñ
                        </button>
                        <button onclick="forceRestore()"
                            style="flex: 1; padding: 8px; background: white; border: 1px solid #6c5ce7; color: #6c5ce7; border-radius: 5px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 5px;">
                            ‚¨áÔ∏è ÊâãÂãï„É≠„Éº„Éâ
                        </button>
                    </div>
                    <div style="font-size: 10px; color: #888; margin-top: 5px; text-align: center;">
                        ‚ÄªÁ´ØÊú´Â§âÊõ¥ÊôÇ„ÅØ„ÄåÊâãÂãï„Çª„Éº„Éñ„Äç„ÇíÊäº„Åó„Å¶‰∏ã„Åï„ÅÑ„ÄÇ
                    </div>
                </div>

                <!-- Login / Logout Btn -->
                <button id="profileAuthBtn" onclick="handleProfileAuth()"
                    style="width: 100%; padding: 12px; background: #667eea; color: white; border: none; border-radius: 10px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <img id="googleIconEntry" src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg"
                        width="18" height="18">
                    <span>Google„Åß„É≠„Ç∞„Ç§„É≥</span>
                </button>
                <div id="loginIncentiveText" style="font-size: 11px; color: #888; text-align: center; margin-top: 5px;">
                    „Éá„Éº„Çø„Çí„ÇØ„É©„Ç¶„Éâ„Å´‰øùÂ≠òÂá∫Êù•„Åæ„Åô„ÄÇ
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyBsS2T5UG2THIOC4zlm6dD9C1UjimFa6xI",
            authDomain: "tenioha-game.firebaseapp.com",
            projectId: "tenioha-game",
            storageBucket: "tenioha-game.firebasestorage.app",
            messagingSenderId: "183973262426",
            appId: "1:183973262426:web:eb54502c744666f07a9463",
            measurementId: "G-QHRLNKJ4CH"
        };

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, doc, setDoc, getDoc, getDocs, query, orderBy, limit, where, Timestamp, serverTimestamp, arrayUnion, runTransaction, increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

        // Global Firebase References
        let db = null;
        let userId = localStorage.getItem('vocabGame_userId');

        // Generate User ID if missing
        if (!userId) {
            userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('vocabGame_userId', userId);
        }

        let auth = null;
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            window.firestoreDb = db; // Expose DB
            window.firebaseAuth = auth; // Expose Auth
            console.log("Firebase initialized successfully");
        } catch (e) {
            console.error("Firebase initialization failed:", e);
        }

        // --- EXPORTED FUNCTIONS ---

        // 1. Upload/Sync Score

        // 1. Upload/Sync Score
        window.uploadScore = async function (name, score) {
            if (!db) return;
            try {
                await setDoc(doc(db, "leaderboard", userId), {
                    name: name,
                    score: Math.floor(score),
                    updatedAt: serverTimestamp()
                }, { merge: true });
                console.log("Score uploaded:", score);
            } catch (e) {
                console.error("Error uploading score:", e);
            }
        };

        // 2. Fetch Leaderboard
        window.fetchLeaderboard = async function (type) {
            if (!db) return { error: "Firebase not connected" };

            try {
                const leaderboardRef = collection(db, "leaderboard");
                let results = [];

                if (type === 'top') {
                    const q = query(leaderboardRef, orderBy("score", "desc"), limit(20));
                    const snapshot = await getDocs(q);
                    let rank = 1;
                    snapshot.forEach(doc => {
                        results.push({
                            rank: rank++,
                            name: doc.data().name || "Unknown",
                            score: doc.data().score,
                            isMe: (doc.id === userId)
                        });
                    });
                } else if (type === 'around') {
                    const myDoc = await getDoc(doc(db, "leaderboard", userId));
                    if (!myDoc.exists()) return { results: [] };
                    const myScore = myDoc.data().score;
                    const qAbove = query(leaderboardRef, where("score", ">", myScore), orderBy("score", "asc"), limit(4));
                    const sAbove = await getDocs(qAbove);
                    const qBelow = query(leaderboardRef, where("score", "<", myScore), orderBy("score", "desc"), limit(4));
                    const sBelow = await getDocs(qBelow);

                    let above = []; sAbove.forEach(d => above.push({ name: d.data().name, score: d.data().score }));
                    let below = []; sBelow.forEach(d => below.push({ name: d.data().name, score: d.data().score }));

                    results = [
                        ...above.reverse().map(u => ({ ...u, rank: '‚ñ≤' })),
                        { name: myDoc.data().name, score: myScore, rank: 'You', isMe: true },
                        ...below.map(u => ({ ...u, rank: '‚ñº' }))
                    ];
                }
                return { results: results };
            } catch (e) {
                return { error: e.message };
            }
        };

        // 3. Auth Functions & Profile Logic

        // Profile Helpers
        window.toggleProfileModal = function () {
            const modal = document.getElementById('profileModal');
            if (modal.style.display === 'flex') {
                modal.style.display = 'none';
            } else {
                modal.style.display = 'flex';
                updatePremiumStatusDisplay();
            }
        };
        window.openProfileModal = function () {
            document.getElementById('profileModal').style.display = 'flex';
            updatePremiumStatusDisplay();
        };
        window.closeProfileModal = function () {
            document.getElementById('profileModal').style.display = 'none';
        };

        function updatePremiumStatusDisplay() {
            const isUnlocked = localStorage.getItem('vocabGame_isUnlocked') === 'true';
            const expiryTime = parseInt(localStorage.getItem('vocabGame_expiry') || '0');
            const tag = document.getElementById('planStatusTag');
            const activationSection = document.getElementById('premiumActivationSection');

            // Expiration Check (Local Enforcement)
            const now = Date.now();
            const isExpired = expiryTime > 0 && now > expiryTime;

            if (isExpired && isUnlocked) {
                // Auto-lock if expired locally
                localStorage.setItem('vocabGame_isUnlocked', 'false');
                // Reload to apply lock? Or just update UI. Let's update UI for now.
            }

            const effectivePremium = isUnlocked && !isExpired;

            if (tag) {
                if (effectivePremium) {
                    const expiryDate = new Date(expiryTime);
                    const isPermanent = expiryDate.getFullYear() > 3000;
                    const dateStr = (expiryTime > 0 && !isPermanent) ? expiryDate.toLocaleDateString() : "ÁÑ°ÊúüÈôê";
                    tag.textContent = `„Éó„É¨„Éü„Ç¢„É† (ÊúüÈôê: ${dateStr})`;
                    tag.style.background = "#2ecc71"; // Green
                    if (activationSection) activationSection.style.display = 'block'; // Allow extending
                } else {
                    tag.textContent = isExpired ? "ÊúüÈôêÂàá„Çå (ÂÜçÊúâÂäπÂåñ„ÅåÂøÖË¶Å)" : "ÁÑ°Êñô„Éó„É©„É≥ (Âà∂Èôê„ÅÇ„Çä)";
                    tag.style.background = "#95a5a6"; // Gray
                    if (activationSection) activationSection.style.display = 'block'; // Show input
                }
            }
        }

        window.handleProfileAuth = function () {
            if (auth.currentUser) {
                if (confirm("„É≠„Ç∞„Ç¢„Ç¶„Éà„Åó„Åæ„Åô„ÅãÔºü")) { logoutGoogle(); }
            } else {
                loginWithGoogle();
            }
        };

        // --- PREMIUM SYSTEM ---
        // --- PREMIUM SYSTEM ---
        window.redeemPromoCode = async function (inputId = 'promoCodeInput') {
            const input = document.getElementById(inputId);
            if (!input) return;
            const code = input.value.trim();

            if (!code) { alert("„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ"); return; }
            if (!auth || !auth.currentUser) { alert("„Ç≥„Éº„Éâ„ÇíÈÅ©Áî®„Åô„Çã„Å´„ÅØ„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô"); return; }

            try {
                await runTransaction(db, async (transaction) => {
                    // 1. Get Refs
                    const codeDocRef = doc(db, "promocodes", code);
                    const userRef = doc(db, "users", auth.currentUser.uid);

                    const codeDoc = await transaction.get(codeDocRef);
                    const userSnap = await transaction.get(userRef);

                    // 2. Validate Code Existence & Activity
                    if (!codeDoc.exists() || codeDoc.data().active !== true) {
                        throw "„Ç≥„Éº„Éâ„ÅåÁÑ°Âäπ„Åã„ÄÅÊúüÈôêÂàá„Çå„Åß„Åô„ÄÇ";
                    }

                    const codeData = codeDoc.data();
                    const durationDays = codeData.durationDays || 30;

                    // 3. Check Usage Limit (New Feature)
                    if (codeData.maxRedemptions) {
                        const currentCount = codeData.redemptionCount || 0;
                        if (currentCount >= codeData.maxRedemptions) {
                            throw "„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØÂà©Áî®‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ";
                        }
                    }

                    // 4. Validate User Status
                    let userData = userSnap.exists() ? userSnap.data() : {};

                    // Check Duplicate Usage
                    if (userData.redeemedCodes && userData.redeemedCodes.includes(code)) {
                        throw "„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØÊó¢„Å´‰ΩøÁî®Ê∏à„Åø„Åß„Åô„ÄÇ";
                    }

                    // 5. Calculate New Expiration
                    let currentExpiry = 0;
                    if (userData.premiumExpiresAt) {
                        currentExpiry = userData.premiumExpiresAt.toMillis();
                    }

                    const now = Date.now();
                    let newExpiryTime;

                    if (currentExpiry > now) {
                        newExpiryTime = currentExpiry + (durationDays * 24 * 60 * 60 * 1000);
                    } else {
                        newExpiryTime = now + (durationDays * 24 * 60 * 60 * 1000);
                    }

                    const newExpiryTimestamp = Timestamp.fromMillis(newExpiryTime);

                    // 6. Perform Updates (Atomic)
                    transaction.set(userRef, {
                        isPremium: true,
                        premiumExpiresAt: newExpiryTimestamp,
                        premiumSource: 'promo_code',
                        lastActivatedAt: serverTimestamp(),
                        usedCode: code,
                        redeemedCodes: arrayUnion(code)
                    }, { merge: true });

                    // Increment Usage Count on Code
                    transaction.update(codeDocRef, {
                        redemptionCount: increment(1)
                    });

                    // 7. Store Local Data for UI (Side Effect separate from Transaction)
                    // (We can't do local storage inside transaction effectively, pass data out)
                    return { newExpiryTime, durationDays, newExpiryDate: new Date(newExpiryTime) };
                }).then((result) => {
                    // Transaction Success
                    const { newExpiryTime, durationDays, newExpiryDate } = result;

                    // 3. Unlock Locally
                    localStorage.setItem('vocabGame_isUnlocked', 'true');
                    localStorage.setItem('vocabGame_expiry', newExpiryTime);
                    updatePremiumStatusDisplay();

                    // 4. Force Unlock Trial
                    if (typeof trialState !== 'undefined') {
                        trialState.unlocked = true;
                        if (typeof saveTrialState === 'function') saveTrialState();
                        if (typeof updateTrialUI === 'function') updateTrialUI();
                        document.getElementById('trialOverlay').style.display = 'none';
                    }

                    alert(`„Éó„É¨„Éü„Ç¢„É†Ê©üËÉΩ„ÅåÊúâÂäπÂåñ„Åï„Çå„Åæ„Åó„ÅüÔºÅ\nÊúâÂäπÊúüÈôê: ${newExpiryDate.toLocaleDateString()} „Åæ„Åß\nÊó•Êï∞: +${durationDays}Êó•`);
                    input.value = "";

                });

            } catch (e) {
                console.error(e);
                // Handle thrown strings as alerts
                if (typeof e === 'string') {
                    alert(e);
                } else {
                    alert("„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: " + e.message);
                }
            }
        };

        // Bridge function for Lock Screen
        window.unlockGame = function () {
            // Use the new Cloud Validation logic
            redeemPromoCode('unlockPassword');
        };

        window.loginWithGoogle = async function () {
            if (!auth) {
                alert("Firebase Auth„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ\n„Éö„Éº„Ç∏„Çí„É™„É≠„Éº„Éâ„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
                return;
            }
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Login Failed:", error);

                let msg = "„É≠„Ç∞„Ç§„É≥„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ";
                if (error.code === 'auth/popup-blocked') msg += "\n„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Åå„Éñ„É≠„ÉÉ„ÇØ„Åï„Çå„Åæ„Åó„Åü„ÄÇË®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
                if (error.code === 'auth/cancelled-popup-request') msg += "\n„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÈñâ„Åò„Çâ„Çå„Åæ„Åó„Åü„ÄÇ";
                if (error.code === 'auth/popup-closed-by-user') msg += "\n„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÈñâ„Åò„Çâ„Çå„Åæ„Åó„Åü„ÄÇ";
                if (error.code === 'auth/unauthorized-domain') msg += "\nË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Éâ„É°„Ç§„É≥„Åß„Åô„ÄÇ\nFirebase Console„Åß„Éâ„É°„Ç§„É≥„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";
                if (error.code === 'auth/operation-not-allowed') msg += "\nGoogle„É≠„Ç∞„Ç§„É≥„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ\nFirebase Console„ÅßÊúâÂäπ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ";

                alert(`${msg}\n\n(Error Code: ${error.code})\n${error.message}`);
            }
        };

        window.logoutGoogle = async function () {
            if (!auth) return;
            try {
                await signOut(auth);
                alert("„É≠„Ç∞„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„Åü");
                location.reload();
            } catch (error) {
                console.error(error);
            }
        };

        // Auth State Listener
        if (auth) {
            onAuthStateChanged(auth, async (user) => {
                // UI Elements
                const headerIcon = document.getElementById('headerProfileIcon');
                const headerInitials = document.getElementById('headerProfileInitials');
                const headerImage = document.getElementById('headerProfileImage');

                const modalImage = document.getElementById('modalProfileImage');
                const modalInitials = document.getElementById('modalProfileInitials');
                const modalName = document.getElementById('modalUserName');
                const modalEmail = document.getElementById('modalUserEmail');
                const authBtn = document.getElementById('profileAuthBtn');
                const syncSection = document.getElementById('profileSyncSection');
                const lastSync = document.getElementById('profileLastSync');

                if (user) {
                    // --- LOGGED IN ---
                    console.log("Auth: Logged in as", user.uid);
                    userId = user.uid; // Switch to Auth ID
                    localStorage.setItem('vocabGame_userId', userId);

                    // Update Header
                    if (headerImage) { headerImage.src = user.photoURL; headerImage.style.display = 'block'; }
                    if (headerInitials) headerInitials.style.display = 'none';
                    if (headerIcon) headerIcon.style.border = "2px solid #2ecc71"; // Green border

                    // --- LEADERBOARD SYNC ---
                    // --- LEADERBOARD SYNC ---
                    // Improved: Only set Google Name if NO name is registered
                    if (typeof window.uploadScore === 'function') {
                        const currentPoints = (typeof gameState !== 'undefined') ? gameState.points : 0;

                        // Check if name is already set locally or wait for cloud sync?
                        // Better to rely on Cloud Sync logic below to fetch name.
                        // Only set default if we are sure?
                        // Actually, let's defer this. The logic below (Step 3) fetches the name.
                        // If that returns empty, THEN we can default to Google Name.

                        // Temporary placeholder - we will handle name syncing in the async block below
                        // to avoid overwriting custom names.
                    }

                    // Update Modal
                    if (modalImage) { modalImage.src = user.photoURL; modalImage.style.display = 'block'; }
                    if (modalInitials) modalInitials.style.display = 'none';
                    if (modalName) modalName.textContent = user.displayName;
                    if (modalEmail) modalEmail.textContent = user.email;

                    if (authBtn) {
                        authBtn.innerHTML = `<span>„É≠„Ç∞„Ç¢„Ç¶„Éà</span>`;
                        authBtn.style.background = "#bdc3c7";
                    }
                    if (syncSection) syncSection.style.display = 'block';

                    // --- SMART SYNC LOGIC ---
                    try {
                        const userDoc = await getDoc(doc(db, "users", userId));

                        // 1. Premium Status Sync (Subscription Model)
                        if (userDoc.exists()) {
                            const data = userDoc.data();
                            let cloudExpiresAt = 0;

                            // Check Expiration
                            if (data.premiumExpiresAt) {
                                cloudExpiresAt = data.premiumExpiresAt.toMillis();
                            } else if (data.isPremium === true) {
                                // Legacy Cloud Users: Permanent
                                cloudExpiresAt = 253402300799000;
                            } else {
                                // No Cloud Premium Data
                                const localUnlocked = localStorage.getItem('vocabGame_isUnlocked') === 'true';
                                if (localUnlocked) {
                                    console.log("Local is Premium (Legacy). Migrating to Cloud (Permanent)...");
                                    // Grant Permanent for Legacy Users
                                    cloudExpiresAt = 253402300799000;
                                    await setDoc(doc(db, "users", userId), {
                                        isPremium: true, // Legacy Marker
                                        premiumExpiresAt: Timestamp.fromMillis(cloudExpiresAt),
                                        premiumSource: 'legacy_migration',
                                        premiumActivatedAt: serverTimestamp()
                                    }, { merge: true });
                                }
                            }

                            localStorage.setItem('vocabGame_expiry', cloudExpiresAt);

                            const now = Date.now();
                            const isValid = cloudExpiresAt > now;

                            if (isValid) {
                                localStorage.setItem('vocabGame_isUnlocked', 'true');
                            } else {
                                localStorage.setItem('vocabGame_isUnlocked', 'false');
                            }
                            updatePremiumStatusDisplay();

                            // BUGFIX: Immediately update in-memory trial state and hide overlay
                            if (isValid) {
                                if (typeof trialState !== 'undefined') {
                                    trialState.unlocked = true;
                                    saveTrialState(); // Persist simple unlocked state
                                    updateTrialUI();
                                }
                                const overlay = document.getElementById('trialOverlay');
                                if (overlay) overlay.style.display = 'none';
                            }
                        }

                        // 2. Data Sync
                        if (userDoc.exists() && userDoc.data().saveData) {
                            const cloudData = JSON.parse(userDoc.data().saveData);
                            const cloudTime = cloudData.lastSaveTime || 0;

                            if (lastSync) lastSync.textContent = new Date(cloudTime).toLocaleString();

                            const localStr = localStorage.getItem('vocabClickerSave');
                            const localData = localStr ? JSON.parse(localStr) : null;
                            const localTime = localData ? (localData.lastSaveTime || 0) : 0;

                            console.log(`Sync Check: Cloud(${new Date(cloudTime).toLocaleTimeString()}) vs Local(${new Date(localTime).toLocaleTimeString()})`);

                            if (cloudTime > localTime) {
                                console.log("Cloud is newer. Auto-Restoring...");
                                localStorage.setItem('vocabClickerSave', userDoc.data().saveData);
                                alert("„ÇØ„É©„Ç¶„Éâ‰∏ä„ÅÆÊúÄÊñ∞„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åó„Åü„ÄÇ\nÂêåÊúü„Åó„Å¶ÂÜçË™≠„ÅøËæº„Åø„Åó„Åæ„Åô„ÄÇ");
                                location.reload();
                            } else {
                                console.log("Local is newer or same. Keeping local.");
                                if (localTime > cloudTime) {
                                    console.log("Pushing newer local data to cloud...");
                                    uploadSaveData(true);
                                }
                            }
                        } else {
                            console.log("No cloud data. Uploading local data...");
                            uploadSaveData(true);
                        }
                    } catch (e) { console.error("Sync Check Failed:", e); }

                    // 3. Sync Leaderboard Name (Robust)
                    try {
                        const lbDoc = await getDoc(doc(db, "leaderboard", userId));
                        let finalName = localStorage.getItem('vocabGame_playerName'); // Start with local

                        if (lbDoc.exists() && lbDoc.data().name) {
                            // Case A: Cloud has a name. It is the master authority.
                            const cloudName = lbDoc.data().name;
                            if (cloudName !== finalName) {
                                console.log(`Name Sync: Cloud '${cloudName}' overrides local '${finalName}'`);
                                finalName = cloudName;
                                localStorage.setItem('vocabGame_playerName', finalName);
                                playerName = finalName;
                            }
                        } else {
                            // Case B: Cloud has NO name (New User for Leaderboard).
                            // If local is also empty, use Google Display Name.
                            if (!finalName && user.displayName) {
                                console.log(`Name Sync: New user, defaulting to Google Name '${user.displayName}'`);
                                finalName = user.displayName;
                                localStorage.setItem('vocabGame_playerName', finalName);
                                playerName = finalName;
                            }
                            // Now upload this initial name to Cloud
                            if (finalName && window.uploadScore) {
                                window.uploadScore(finalName, (typeof gameState !== 'undefined') ? gameState.points : 0);
                            }
                        }
                    } catch (e) { console.error("Name Sync Failed:", e); }

                    // Start Auto-Save Loop
                    startAutoSaveLoop();

                } else {
                    // --- LOGGED OUT ---
                    console.log("Auth: Signed out");

                    // Reset Header
                    if (headerImage) headerImage.style.display = 'none';
                    if (headerInitials) headerInitials.style.display = 'block';
                    if (headerIcon) headerIcon.style.border = "2px solid white";

                    // Reset Modal
                    if (modalImage) modalImage.style.display = 'none';
                    if (modalInitials) modalInitials.style.display = 'block';
                    if (modalName) modalName.textContent = "„Ç≤„Çπ„Éà„É¶„Éº„Ç∂„Éº";
                    if (modalEmail) modalEmail.textContent = "Êú™„É≠„Ç∞„Ç§„É≥";

                    if (authBtn) {
                        authBtn.innerHTML = `<img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" width="18" height="18"><span>Google„Åß„É≠„Ç∞„Ç§„É≥</span>`;
                        authBtn.style.background = "#667eea";
                    }
                    if (syncSection) syncSection.style.display = 'none';

                    // Stop Auto-Save
                    if (window.autoSaveInterval) clearInterval(window.autoSaveInterval);
                }
            });
        }

        // --- AUTO SAVE LOOP ---
        function startAutoSaveLoop() {
            if (window.autoSaveInterval) clearInterval(window.autoSaveInterval);
            console.log("AutoManager: Auto-Save started (60s interval)");
            window.autoSaveInterval = setInterval(() => {
                if (auth && auth.currentUser) {
                    console.log("AutoManager: Performing Auto-Save...");
                    uploadSaveData(true);
                }
            }, 60000); // 60 seconds
        }

        // Modified Upload/Restore for Auth
        window.forceBackup = async function () {
            await uploadSaveData();
        };

        window.forceRestore = async function () {
            if (!db || !auth.currentUser) return;
            if (!confirm("„ÇØ„É©„Ç¶„Éâ‰∏ä„ÅÆ„Éá„Éº„Çø„Åß‰∏äÊõ∏„Åç„Åó„Åæ„Åô„ÅãÔºü\\n‰ªä„ÅÆÁ´ØÊú´„ÅÆÊú™‰øùÂ≠ò„Éá„Éº„Çø„ÅØÊ∂à„Åà„Åæ„Åô„ÄÇ")) return;

            try {
                const userDoc = await getDoc(doc(db, "users", auth.currentUser.uid));
                if (!userDoc.exists() || !userDoc.data().saveData) { alert("„ÇØ„É©„Ç¶„Éâ„Å´„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì"); return; }

                // Restore Logic
                localStorage.setItem('vocabClickerSave', userDoc.data().saveData);
                alert("Âæ©ÂÖÉ„Åó„Åæ„Åó„Åü„ÄÇ„É™„É≠„Éº„Éâ„Åó„Åæ„Åô„ÄÇ");
                location.reload();
            } catch (e) { alert("„Ç®„É©„Éº: " + e.message); }
        };

        // Overwrite existing uploadSaveData to use Auth if available
        window.uploadSaveData = async function (silent = false) {
            if (!db) return;
            if (!auth || !auth.currentUser) {
                if (!silent) alert("„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åß„Åô");
                return;
            }

            const saveData = localStorage.getItem('vocabClickerSave');
            if (!saveData) return;

            try {
                // Update Last Save Time in Data before sending?
                // Ideally yes, but we rely on saveGame() being called before.
                // But let's verify if we need to update it manually?
                // The saveData string is from LocalStorage. 
                // If we upload OLD data, the timestamp is old.
                // We should assume local storage is fresh.

                await setDoc(doc(db, "users", auth.currentUser.uid), {
                    saveData: saveData,
                    updatedAt: serverTimestamp(),
                    name: auth.currentUser.displayName,
                    email: auth.currentUser.email
                }, { merge: true });

                if (!silent) {
                    alert("‰øùÂ≠òÂÆå‰∫ÜÔºÅ");
                    const lastSync = document.getElementById('profileLastSync');
                    if (lastSync) lastSync.textContent = new Date().toLocaleString();
                } else {
                    // Update UI silently if open
                    const lastSync = document.getElementById('profileLastSync');
                    if (lastSync) lastSync.textContent = new Date().toLocaleString();
                }
            } catch (e) {
                if (!silent) alert("Â§±Êïó: " + e.message);
                console.error(e);
            }
        };
    </script>

    <script>
        // Modal Logic
        const wordbookBtn = document.getElementById('wordbookBtn');
        const wordbookModal = document.getElementById('wordbookModal');
        const closeWordbookModal = document.getElementById('closeWordbookModal');
        const wordbookItems = document.querySelectorAll('.wordbook-item-btn');

        if (wordbookBtn) {
            wordbookBtn.addEventListener('click', () => {
                wordbookModal.style.display = 'flex';
            });
        }

        if (closeWordbookModal) {
            closeWordbookModal.addEventListener('click', () => {
                wordbookModal.style.display = 'none';
            });
        }

        // Help Modal Logic
        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const closeHelpModal = document.getElementById('closeHelpModal');

        if (helpBtn) {
            helpBtn.addEventListener('click', () => {
                helpModal.style.display = 'flex';
            });
        }

        if (closeHelpModal) {
            closeHelpModal.addEventListener('click', () => {
                helpModal.style.display = 'none';
            });
        }

        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.style.display = 'none';
            }
        });

        wordbookModal.addEventListener('click', (e) => {
            if (e.target === wordbookModal) {
                wordbookModal.style.display = 'none';
            }
        });

        wordbookItems.forEach(btn => {
            btn.addEventListener('click', () => {
                const level = btn.dataset.level;
                switchLevel(level);
                wordbookModal.style.display = 'none';
            });
        });


        if ('serviceWorker' in navigator) {
            let refreshing = false;

            // 1. Listen for new version activation
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                if (refreshing) return;
                refreshing = true;
                console.log("New version detected. Saving and reloading...");
                if (window.saveGame) window.saveGame(); // Safety Save
                window.location.reload();
            });

            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service_worker.js').then(reg => {
                    console.log('Service Worker Registered!', reg);

                    // 2. Check for updates when app comes to foreground
                    document.addEventListener('visibilitychange', () => {
                        if (document.visibilityState === 'visible') {
                            reg.update().catch(e => console.log('SW update check failed', e));
                        }
                    });
                }).catch(err => console.log('Service Worker registration failed: ', err));
            });
        }

        // --- PWA INSTALL LOGIC ---
        let deferredPrompt;
        const installContainer = document.getElementById('installAppContainer');
        const installBtnHelper = document.getElementById('pwaInstallBtn'); // Help Modal
        const installBtnProfile = document.getElementById('profileInstallBtn'); // Profile Modal

        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later.
            deferredPrompt = e;

            console.log("PWA Install Prompt ready");

            // Enable Helper Button
            if (installBtnHelper) {
                installBtnHelper.style.background = "#e17055"; // Orange
                installBtnHelper.style.cursor = "pointer";
                installBtnHelper.style.boxShadow = "0 4px 6px rgba(0,0,0,0.1)";
            }
            const desc = document.getElementById('pwaInstallDesc');


            // Enable Profile Button
            if (installBtnProfile) {
                installBtnProfile.style.display = 'block';
                installBtnProfile.style.background = "#e17055";
                installBtnProfile.style.color = "white";
                installBtnProfile.style.border = "none";
            }
        });

        const installApp = () => {
            // If not ready, show alert or do nothing
            if (!deferredPrompt) {
                alert("„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„Åß„ÅØËá™Âãï„Ç§„É≥„Çπ„Éà„Éº„É´„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ\n„Éñ„É©„Ç¶„Ç∂„ÅÆ„É°„Éã„É•„Éº„Äå„Éõ„Éº„É†ÁîªÈù¢„Å´ËøΩÂä†„Äç„Å™„Å©„Åã„Çâ„Ç§„É≥„Çπ„Éà„Éº„É´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
                return;
            }

            // Show the prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('User accepted the A2HS prompt');
                } else {
                    console.log('User dismissed the A2HS prompt');
                }
                deferredPrompt = null;
            });
        };

        if (installBtnHelper) installBtnHelper.addEventListener('click', installApp);
        if (installBtnProfile) installBtnProfile.addEventListener('click', installApp);

        window.addEventListener('appinstalled', () => {
            console.log('PWA was installed');
            if (installContainer) installContainer.style.display = 'none';
            if (installBtnProfile) installBtnProfile.style.display = 'none';
        });
    </script>
</body>

</html>